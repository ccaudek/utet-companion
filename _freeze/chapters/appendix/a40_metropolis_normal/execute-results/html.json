{
  "hash": "7b706b4d640c2279cb4af99b88315689",
  "result": {
    "engine": "knitr",
    "markdown": "# Metropolis: esempio Normale–Normale {#sec-apx-metropolis-normal}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhere::here(\"code\", \"_common.R\") |> \n  source()\n\n# Load packages\nif (!requireNamespace(\"pacman\")) install.packages(\"pacman\")\npacman::p_load(cmdstanr)\n```\n:::\n\n\nIn questa sezione di approfondimento applichiamo l’algoritmo di Metropolis a un caso in cui conosciamo la soluzione analitica: il modello Normale–Normale. L’obiettivo non è introdurre concetti nuovi, ma mostrare ancora una volta come l’algoritmo riesca a ricostruire una distribuzione a posteriori già nota, rafforzando l’intuizione costruita nel testo principale.\n\nSupponiamo di voler stimare la media vera $\\mu$ di una popolazione. Abbiamo:\n\n* un prior $\\mu \\sim \\mathcal{N}(30, 5^2)$,\n* un insieme di dati $y$ (30 osservazioni di punteggi BDI-II),\n* una verosimiglianza normale con deviazione standard stimata dai dati.\n\nIl modello è quindi:\n\n$$\ny_i \\sim \\mathcal{N}(\\mu, \\sigma^2), \\qquad \\mu \\sim \\mathcal{N}(30, 25).\n$$\n\n## Implementazione in R\n\n**Definizione delle funzioni prior, likelihood e posterior (non normalizzata):**\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprior <- function(mu) dnorm(mu, mean = 30, sd = 5)\n\nlikelihood <- function(mu, data) {\n  sigma <- sd(data)\n  prod(dnorm(data, mean = mu, sd = sigma))\n}\n\nposterior <- function(mu, data) {\n  prior(mu) * likelihood(mu, data)\n}\n```\n:::\n\n\n**Algoritmo di Metropolis:**\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmetropolis_for_normal <- function(nsamp, xinit, data) {\n  samples <- numeric(nsamp)\n  x_prev <- xinit\n  for (i in seq_len(nsamp)) {\n    x_star <- rnorm(1, mean = x_prev, sd = 0.5)\n    if (runif(1) < min(1, posterior(x_star, data) / posterior(x_prev, data))) {\n      x_prev <- x_star\n    }\n    samples[i] <- x_prev\n  }\n  samples\n}\n```\n:::\n\n\n**Dati osservati:**\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ny <- c(\n  26, 35, 30, 25, 44, 30, 33, 43, 22, 43,\n  24, 19, 39, 31, 25, 28, 35, 30, 26, 31,\n  41, 36, 26, 35, 33, 28, 27, 34, 27, 22\n)\n```\n:::\n\n\nEsecuzione del campionamento:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(123)\nsamples <- metropolis_for_normal(100000, mean(y), y)\n```\n:::\n\n\n## Confronto con la soluzione analitica\n\nNel caso Normale–Normale possiamo calcolare i parametri della distribuzione a posteriori esatta:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmu_prior <- 30; std_prior <- 5; var_prior <- std_prior^2\nn <- length(y); sum_y <- sum(y); var_data <- var(y)\n\nmu_post <- (mu_prior / var_prior + sum_y / var_data) / (1 / var_prior + n / var_data)\nvar_post <- 1 / (1 / var_prior + n / var_data)\nstd_post <- sqrt(var_post)\n\nc(mu_post = mu_post, sd_post = std_post)\n#> mu_post sd_post \n#>   30.88    1.17\n```\n:::\n\n\nInfine, confrontiamo graficamente l’istogramma dei campioni MCMC (dopo burn-in) con la densità analitica:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nburnin <- 50000\npost_samples <- samples[(burnin+1):length(samples)]\n\nggplot() +\n  geom_histogram(\n    aes(x = post_samples, y = after_stat(density)),\n    bins = 30, fill = \"#56B4E9\", alpha = 0.5, color = NA\n  ) +\n  stat_function(\n    fun = dnorm, args = list(mean = mu_post, sd = std_post),\n    color = \"#009E73\", linewidth = 1.2\n  ) +\n  labs(x = expression(mu), y = \"Densità\") \n```\n\n::: {.cell-output-display}\n![](a40_metropolis_normal_files/figure-html/unnamed-chunk-7-1.png){fig-align='center' width=85%}\n:::\n:::\n\n\nIn conclusione, questo esempio conferma che l’algoritmo di Metropolis riesce a ricostruire accuratamente la distribuzione a posteriori anche in un modello con soluzione analitica nota. Dal punto di vista didattico, ciò offre un’ulteriore verifica intuitiva della validità dell’algoritmo.\n\n",
    "supporting": [
      "a40_metropolis_normal_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}