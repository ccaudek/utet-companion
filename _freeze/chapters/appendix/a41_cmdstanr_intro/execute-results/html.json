{
  "hash": "0925cb157fc11d693ba650c41c149d1a",
  "result": {
    "engine": "knitr",
    "markdown": "# Implementazione di modelli Bayesiani con Stan tramite `cmdstanr` {#sec-cmdstanr-intro}\n\n\n## Obiettivo {.unnumbered .unlisted} \n\nIn questa sezione dell'appendice presentiamo una guida pratica all'implementazione di modelli Bayesiani utilizzando *Stan* attraverso l'interfaccia *cmdstanr* in R. Il framework `cmdstanr` rappresenta l'evoluzione moderna delle interfacce R per Stan, offrendo prestazioni ottimizzate e un workflow semplificato per l'inferenza Bayesiana.\n\nIllustreremo il flusso di lavoro completo attraverso i seguenti passaggi:\n\n1. *Preparazione e input dei dati*: strutturare i dati per l'analisi in Stan.\n2. *Compilazione del modello*: trasformazione del codice Stan in eseguibile ottimizzato.\n3. *Campionamento MCMC*: esecuzione efficiente degli algoritmi di campionamento.\n4. *Estrazione e analisi dei risultati*: elaborazione degli output campionati.\n5. *Diagnostica e visualizzazione*: validazione del modello e rappresentazione grafica.\n\n\n## Perché usare CmdStanR\n\n`CmdStanR` è l'interfaccia R per CmdStan, la versione più leggera e flessibile di Stan. A differenza di `rstan`, che integra il compilatore C++ dentro R, `CmdStanR` utilizza direttamente gli eseguibili di CmdStan. Questo porta diversi vantaggi:\n\n-   *Maggiore stabilità e velocità di compilazione*, grazie all'uso diretto di CmdStan.\n-   *Aggiornamenti indipendenti*: CmdStanR si appoggia a CmdStan, che può essere aggiornato separatamente.\n-   *Controllo avanzato* sulle opzioni di campionamento, diagnostica e gestione dei file di output.\n-   *Portabilità*: funziona in modo coerente su diversi sistemi operativi.\n\nInoltre, `CmdStanR` rappresenta oggi la soluzione consigliata dagli sviluppatori Stan, in quanto più manutenuta e allineata con le versioni più recenti del linguaggio.\n\n\n## Installazione\n\nPer prima cosa, installiamo il pacchetto `cmdstanr` da GitHub:\n\n``` r\n# install.packages(\"pak\")\npak::pak(\"stan-dev/cmdstanr\")\n```\n\nDopodiché, occorre installare CmdStan:\n\n``` r\ncmdstanr::install_cmdstan()\n```\n\nQuesto comando scarica e compila CmdStan localmente. La prima installazione può richiedere qualche minuto, ma successivamente sarà sufficiente aggiornare all’occorrenza con:\n\n``` r\ncmdstanr::install_cmdstan(update = TRUE)\n```\n\nPer verificare la corretta installazione:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(cmdstanr)\ncmdstanr::cmdstan_version()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2.37.0\"\n```\n\n\n:::\n:::\n\n\n\n## Pacchetti necessari\n\nPer lavorare ci servono alcuni pacchetti:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressPackageStartupMessages({\n  library(tidyverse)   # per manipolare i dati\n  library(cmdstanr)    # interfaccia R per Stan\n  library(posterior)   # per lavorare con i campioni MCMC\n  library(bayesplot)   # per visualizzare i risultati\n  library(here)        # per gestire i percorsi ai file\n})\n\nset.seed(42) # per riproducibilità\n```\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n## Un esempio semplice: modello beta-binomiale\n\nConsideriamo il seguente scenario sperimentale: in un esperimento bernoulliano abbiamo osservato *6 successi su 9 prove*. L'obiettivo dell'analisi è stimare la distribuzione a posteriori della probabilità di successo $\\theta$. \n\nA questo scopo, adottiamo come distribuzione a priori una *Beta(2, 2)*, scelta in quanto debolmente informativa e in grado di esprimere una moderata convinzione preliminare sulla simmetria della probabilità di successo, pur mantenendo una sufficiente flessibilità per permettere ai dati di guidare l'inferenza.\n\nIl modello Stan è già stato scritto in un file `beta_binomial_model.stan`. Il codice Stan è identico indipendentemente dall’interfaccia (R, Python, Julia, …).\n\n\n### Passare i dati a Stan\n\nStan richiede che i dati siano in una *lista* di R con i nomi esattamente uguali a quelli usati nel file `.stan`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata_list <- list(\n  N = 9,          # numero di prove\n  y = 6,          # numero di successi\n  alpha_prior = 2, # parametri del prior\n  beta_prior = 2\n)\n```\n:::\n\n\n\n### Leggere e compilare il modello\n\nDiciamo a R dove si trova il file `.stan` e lo compiliamo:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfile <- file.path(here::here(\"stan\", \"beta_binomial_model.stan\"))\nfile\n\nmod <- cmdstan_model(file)  # compila il modello\n```\n:::\n\n\nL’oggetto `mod` rappresenta il modello Stan compilato. Possiamo visualizzarne le informazioni:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmod$print()\n#> data {\n#>   int<lower=1> N;                       // numero di prove\n#>   int<lower=0, upper=N> y;              // successi osservati\n#>   real<lower=0> alpha_prior;            // Beta prior: alpha\n#>   real<lower=0> beta_prior;             // Beta prior: beta\n#> }\n#> parameters {\n#>   real<lower=0, upper=1> theta;         // probabilità di successo\n#> }\n#> model {\n#>   // Prior\n#>   theta ~ beta(alpha_prior, beta_prior);\n#>   // Likelihood\n#>   y ~ binomial(N, theta);\n#> }\n#> generated quantities {\n#>   // Replica del dato per pp_check\n#>   int y_rep = binomial_rng(N, theta);\n#> \n#>   // Log-likelihood del dato osservato (per LOO/WAIC)\n#>   real log_lik = binomial_lpmf(y | N, theta);\n#> }\n```\n:::\n\n\n\n### Eseguire l’algoritmo MCMC\n\nPer stimare i parametri usiamo il metodo `$sample()`. Questo esegue l’algoritmo MCMC di Stan:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfit <- mod$sample(\n  data = data_list,\n  seed = 123,\n  chains = 4,            # numero di catene\n  parallel_chains = 4    # quante catene girano in parallelo\n)\n```\n:::\n\n\n**Nota:** per default ogni catena produce 1000 campioni dopo il warmup, quindi avremo 4000 campioni posteriori.\n\n\n### Estrarre i campioni\n\nI campioni possono essere estratti in diversi formati.\nPer esempio, come *array a 3 dimensioni* (iterazioni × catene × variabili):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndraws_arr <- fit$draws()\nstr(draws_arr)\n#>  'draws_array' num [1:1000, 1:4, 1:4] -8.67 -8.76 -8.68 -11.81 -8.71 ...\n#>  - attr(*, \"dimnames\")=List of 3\n#>   ..$ iteration: chr [1:1000] \"1\" \"2\" \"3\" \"4\" ...\n#>   ..$ chain    : chr [1:4] \"1\" \"2\" \"3\" \"4\"\n#>   ..$ variable : chr [1:4] \"lp__\" \"theta\" \"y_rep\" \"log_lik\"\ndim(draws_arr)\n#> [1] 1000    4    4\n```\n:::\n\n\nOppure come *data frame lungo*:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndraws_df <- as_draws_df(fit)\nhead(draws_df)\n#> # A draws_df: 6 iterations, 1 chains, and 4 variables\n#>    lp__ theta y_rep log_lik\n#> 1  -8.7  0.60     8    -1.4\n#> 2  -8.8  0.67     9    -1.3\n#> 3  -8.7  0.59     6    -1.4\n#> 4 -11.8  0.89     9    -2.8\n#> 5  -8.7  0.57     7    -1.5\n#> 6  -8.7  0.61     8    -1.4\n#> # ... hidden reserved variables {'.chain', '.iteration', '.draw'}\n```\n:::\n\n\n\n### Statistiche riassuntive\n\nIl metodo `$summary()` calcola statistiche posteriori (medie, deviazioni standard, quantili, ecc.):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfit$summary(variables = \"theta\")\n#> # A tibble: 1 × 10\n#>   variable  mean median    sd   mad    q5   q95  rhat ess_bulk ess_tail\n#>   <chr>    <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>    <dbl>    <dbl>\n#> 1 theta    0.620  0.628 0.129 0.132 0.394 0.820 1.005 1247.337 1842.290\n```\n:::\n\n\nPossiamo specificare statistiche personalizzate, ad esempio:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfit$summary(\n  variables = \"theta\", \n  mean, \n  sd,\n  ~quantile(.x, probs = c(0.03, 0.97))\n)\n#> # A tibble: 1 × 5\n#>   variable  mean    sd  `3%` `97%`\n#>   <chr>    <dbl> <dbl> <dbl> <dbl>\n#> 1 theta    0.620 0.129 0.362 0.843\n```\n:::\n\n\n### Esempio di test bayesiano\n\nPossiamo stimare la probabilità che $\\theta \\leq 0.5$:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfit$summary(\"theta\", pr_less_05 = ~ mean(. <= 0.5))\n#> # A tibble: 1 × 2\n#>   variable pr_less_05\n#>   <chr>         <dbl>\n#> 1 theta         0.180\n```\n:::\n\n\n\n### Visualizzare i campioni\n\nIl pacchetto `bayesplot` semplifica la creazione di grafici. Ad esempio, un istogramma della distribuzione posteriore di $\\theta$:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmcmc_hist(fit$draws(\"theta\"))\n```\n\n::: {.cell-output-display}\n![](a41_cmdstanr_intro_files/figure-html/unnamed-chunk-13-1.png){fig-align='center' width=85%}\n:::\n:::\n\n\n\n### Diagnostica del campionatore\n\nPer verificare che l’MCMC abbia funzionato correttamente:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfit$diagnostic_summary()\n#> $num_divergent\n#> [1] 0 0 0 0\n#> \n#> $num_max_treedepth\n#> [1] 0 0 0 0\n#> \n#> $ebfmi\n#> [1] 1.150 0.882 1.223 1.165\n```\n:::\n\n\nÈ anche possibile accedere alle variabili interne del campionatore (es. profondità dell’albero, divergenze):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhead(fit$sampler_diagnostics(format = \"df\"))\n#> # A draws_df: 6 iterations, 1 chains, and 6 variables\n#>   treedepth__ divergent__ energy__ accept_stat__ stepsize__ n_leapfrog__\n#> 1           2           0     11.9          1.00       0.93            3\n#> 2           2           0      9.0          0.96       0.93            3\n#> 3           2           0      8.7          1.00       0.93            7\n#> 4           2           0     11.8          0.63       0.93            3\n#> 5           2           0     11.2          1.00       0.93            7\n#> 6           2           0      8.7          1.00       0.93            3\n#> # ... hidden reserved variables {'.chain', '.iteration', '.draw'}\n```\n:::\n\n\nSe ci sono problemi (molte divergenze, R-hat alto, ecc.), occorre rivedere il modello o i parametri di campionamento.\n\n\n### Conclusioni\n\nIn conclusione, abbiamo visto i passaggi fondamentali per usare *cmdstanr*:\n\n1. preparare i dati in una lista;\n2. compilare il modello Stan;\n3. lanciare il campionamento MCMC;\n4. estrarre e riassumere i campioni;\n5. visualizzare i risultati e controllare la diagnostica.\n\nQuesta procedura è la base di ogni analisi con Stan via R: indipendentemente dal modello, i passaggi saranno sempre questi.\n\n",
    "supporting": [
      "a41_cmdstanr_intro_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}