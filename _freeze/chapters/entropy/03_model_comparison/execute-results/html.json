{
  "hash": "19cfc05d7c11471885530b983bf8fe51",
  "result": {
    "engine": "knitr",
    "markdown": "# Valutare i modelli bayesiani  {#sec-div-kl-lppd-elpd}\n\n## Introduzione {.unnumbered .unlisted}\n\nNei capitoli precedenti abbiamo visto due concetti fondamentali: l'*entropia*, che misura l'incertezza insita in una distribuzione, e la *divergenza di Kullback–Leibler* ($D_{\\text{KL}}$), che quantifica la distanza tra due distribuzioni di probabilità. Ora possiamo fare un passo ulteriore: usare queste idee per *valutare e confrontare modelli statistici* nel contesto bayesiano.\n\nIl punto di partenza è una domanda cruciale: *quanto bene il modello riesce a prevedere nuovi dati?*  Un buon modello non deve solo adattarsi ai dati osservati, ma deve anche saper *generalizzare* a situazioni future. Questa distinzione – adattamento vs. generalizzazione – è il cuore della valutazione predittiva.\n\nImmaginiamo, ad esempio, di sviluppare un test psicologico per stimare l'ansia degli studenti prima di un esame. Non basta sapere che il modello descrive bene il campione usato per costruirlo: vogliamo essere ragionevolmente sicuri che le stesse previsioni funzionino anche per studenti che non hanno partecipato allo studio. In psicologia, scegliere tra due modelli è simile a decidere quale test usare: in entrambi i casi si cerca lo strumento che fornisce previsioni più affidabili.\n\n### Panoramica del capitolo {.unnumbered .unlisted}\n\nPer rispondere alla domanda fondamentale sulla qualità predittiva, seguiremo un percorso logico che ci condurrà dagli strumenti teorici ai metodi pratici:\n\n- *Prima costruiremo la base teorica*: vedremo come la *distribuzione predittiva posteriore* incorpora l'incertezza sui parametri nelle nostre previsioni\n- *Poi definiremo le misure di accuratezza*: il *log-score* per valutare la bontà delle previsioni punto per punto\n- *Distingueremo tra valutazione in-sample e out-of-sample*: LPPD (sui dati osservati) vs. ELPD (capacità di generalizzazione)\n- *Collegheremo tutto alla divergenza KL*: per capire perché massimizzare l'ELPD equivale a trovare il modello più vicino alla realtà\n- *Implementeremo metodi pratici*: LOO-CV per stimare l'ELPD senza conoscere la vera distribuzione dei dati\n- *Confronteremo con altri criteri*: AIC, BIC, WAIC e i loro ambiti di applicazione\n\nL'obiettivo è fornire strumenti pratici e un quadro concettuale chiaro per guidare la scelta del modello più adatto al problema in esame.\n\n\n::: {.callout-tip collapse=true}\n## Prerequisiti\n\n- Per comprendere appieno questo capitolo è utile leggere il capitolo 7 *Ulysses’ Compass* di *Statistical Rethinking* (@McElreath_rethinking).\n:::\n\n::: {.callout-caution collapse=true title=\"Preparazione del Notebook\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nhere::here(\"code\", \"_common.R\") |> \n  source()\n\nlibrary(gt)\nlibrary(conflicted)\nlibrary(brms)\nlibrary(loo)\nconflicts_prefer(rstan::loo)\n```\n:::\n\n:::\n\n\n## Il punto di partenza: dalle previsioni deterministiche a quelle probabilistiche\n\nPrima di addentrarci nei dettagli tecnici, facciamo un passo indietro per capire perché la valutazione predittiva bayesiana è diversa da quella frequentista classica.\n\n*Nell'approccio classico*, una volta stimati i parametri (ad esempio con la massima verosimiglianza), li trattiamo come \"veri\" e fissi. Se $\\hat{\\theta}$ è la nostra stima, la previsione per un nuovo dato $\\tilde{y}$ è semplicemente:\n\n$$\np(\\tilde{y} \\mid \\hat{\\theta}).\n$$\nQuesto approccio ignora completamente l'incertezza sulla stima dei parametri.\n\n*Nell'approccio bayesiano*, invece, riconosciamo che i parametri sono incerti. Anche dopo aver osservato i dati, la nostra conoscenza di $\\theta$ è descritta da un'intera distribuzione posteriore $p(\\theta \\mid y)$, non da un singolo valore. Le previsioni devono quindi riflettere questa incertezza.\n\n::: {.callout-note title=\"Analogia didattica\"}\nImmaginiamo di dover prevedere il tempo domani. L'approccio \"classico\" è come consultare un solo meteorologo e fidarsi completamente della sua previsione. L'approccio bayesiano è come consultare tutti i meteorologi disponibili, pesare le loro opinioni in base alla loro affidabilità passata, e costruire una previsione che tenga conto di tutti i punti di vista plausibili.\n:::\n\n## Distribuzione predittiva posteriore: il cuore delle previsioni bayesiane\n\nNel capitolo sul modello *beta–binomiale* l'abbiamo già incontrata: è lo strumento che, nell'approccio bayesiano, consente di prevedere nuovi dati incorporando sia la struttura del modello sia l'incertezza sui parametri. La logica è elegante nella sua semplicità: dopo aver osservato i dati $y$, non otteniamo un singolo \"miglior\" valore dei parametri, ma una *distribuzione posteriore* $p(\\theta \\mid y)$ che quantifica i valori plausibili di $\\theta$ e la nostra incertezza.\n\n> **Esempio concreto:** Uno psicologo che stima il livello medio di ansia in una popolazione, invece di affermare \"la media è 4.7\", dirà: \"il valore più plausibile è 4.7, *ma* è ragionevole che sia tra 4.2 e 5.1\", riflettendo la variabilità della distribuzione a posteriori.\n\n### La formula fondamentale\n\nPer prevedere un nuovo dato $\\tilde{y}$, non fissiamo $\\theta$. *Mediamo* invece tutte le previsioni condizionate $p(\\tilde{y} \\mid \\theta)$ pesandole con la densità posteriore $p(\\theta\\mid y)$:\n\n$$\np(\\tilde{y} \\mid y) = \\int p(\\tilde{y} \\mid \\theta)\\, p(\\theta \\mid y)\\, d\\theta\n$$ {#eq-predictive-posterior}\nQuesta è la *distribuzione predittiva posteriore*, e rappresenta la nostra migliore previsione per dati futuri dato quello che abbiamo osservato.\n\n### Decomposizione dell'integrale: cosa significa realmente\n\nL'@eq-predictive-posterior può sembrare astratta, ma ha un'interpretazione intuitiva molto chiara:\n\n1. $p(\\tilde{y} \\mid \\theta)$: se conoscessimo il vero valore di $\\theta$, questa sarebbe la nostra previsione per $\\tilde{y}$;\n2. $p(\\theta \\mid y)$: questa è la nostra incertezza su quale sia il vero valore di $\\theta$;\n3. *L'integrale*: combina le previsioni per tutti i possibili valori di $\\theta$, pesandole secondo quanto crediamo che ciascun valore sia plausibile.\n\n\n::: {.callout-note collapse=true title=\"Intuizione dettagliata\"}\nSe conoscessimo il valore vero di $\\theta$, potremmo prevedere i dati futuri usando la distribuzione predittiva condizionata:\n\n$$\np(\\tilde y \\mid \\theta).\n$$\nIl problema è che $\\theta$ non lo conosciamo: abbiamo soltanto la distribuzione a posteriori $p(\\theta\\mid y)$. Perciò, la distribuzione predittiva posteriore si costruisce combinando le previsioni condizionate per ogni valore possibile di $\\theta$, pesandole con quanto ciascun valore è plausibile a posteriori:\n\n$$\np(\\tilde y\\mid y) = \\int p(\\tilde y\\mid \\theta)\\,p(\\theta\\mid y)\\,d\\theta.\n$$\nPer fare un esempio concreto, consideriamo il caso binomiale. Supponiamo che i dati futuri siano generati da una Binomiale con $m$ prove e parametro $\\theta$:\n\n$$\np(\\tilde y = x \\mid \\theta) = \\binom{m}{x}\\,\\theta^x(1-\\theta)^{m-x}.\n$$\nLa distribuzione predittiva posteriore diventa:\n\n$$\np(\\tilde y = x \\mid y) = \\int \\binom{m}{x}\\,\\theta^x(1-\\theta)^{m-x}\\,p(\\theta\\mid y)\\,d\\theta.\n$$\nIn alcuni casi particolari (per esempio con prior Beta e dati binomiali) questo integrale si può risolvere analiticamente, ottenendo la *Beta–Binomiale*. Ma in generale non c'è una formula chiusa e serve un'approssimazione numerica.\n\n**Approssimazione numerica con il metodo su griglia:** L'idea è semplice: sostituire l'integrale con una somma pesata su una griglia di valori possibili di $\\theta$. I passaggi algoritmici sono i seguenti.\n\n1. **Definire una griglia di valori di $\\theta$**, ad esempio 1000 punti equispaziati tra 0 e 1:\n\n   $$\n   \\theta_1, \\theta_2, \\dots, \\theta_J.\n   $$\n\n2. **Calcolare la posteriore su ciascun punto della griglia.**\n   Nel caso Beta–Binomiale:\n\n   $$\n   p(\\theta_j \\mid y) \\propto \\theta_j^{\\,k+a-1}(1-\\theta_j)^{n-k+b-1}.\n   $$\n\n   Poi normalizzare per avere somme che valgono 1:\n\n   $$\n   w_j = \\frac{p(\\theta_j \\mid y)}{\\sum_{\\ell=1}^J p(\\theta_\\ell \\mid y)}.\n   $$\n\n3. **Combinare le predizioni condizionate**.\n   Per ogni valore futuro $x=0,\\dots,m$, si calcola:\n\n   $$\n   p(\\tilde y = x \\mid y) \\approx \\sum_{j=1}^J w_j \\, \\binom{m}{x}\\theta_j^x(1-\\theta_j)^{m-x}.\n   $$\n\n4. **Interpretazione**: la pmf ottenuta è la nostra approssimazione numerica della distribuzione predittiva posteriore. Da essa possiamo:\n\n   * calcolare probabilità,\n   * generare campioni di $\\tilde y$,\n   * confrontare la predizione con i dati osservati.\n\n**Da ricordare:**\n\n* La predittiva non si ottiene facendo la media dei valori di $\\tilde y$, ma costruendo **un'intera distribuzione di probabilità**.\n* Il metodo su griglia è il più semplice: discretizza $\\theta$, pesa ogni valore con la sua plausibilità a posteriori, e combina le predizioni condizionate.\n* In problemi più complessi, la stessa logica viene implementata tramite **MCMC**: invece di usare una griglia fissa, si usano campioni $\\theta^{(s)}$ dalla posteriore.\n:::\n\n::: {.callout-note collapse=true title=\"Esempio numerico completo\"}\nEsaminiamo ora uno script in R che implementa passo per passo l'approssimazione della distribuzione predittiva posteriore binomiale con il metodo su griglia. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# ESEMPIO DIDATTICO: predittiva posteriore per Binomiale con metodo su griglia\n# Dati e prior\nk <- 10     # successi osservati\nn <- 50     # prove osservate\na <- 1      # prior Beta(a, b)\nb <- 1\nm <- 10     # numero di prove future per la predizione (scelta didattica)\nJ <- 2000   # numero di punti griglia su theta in [0,1]\n\n# -------------------------------------------------------------\n# PASSAGGIO 1: Griglia su theta\n# -------------------------------------------------------------\n\ntheta <- seq(0, 1, length.out = J)\n\n# -------------------------------------------------------------\n# PASSAGGIO 2: Densità posteriore non normalizzata su ogni punto di griglia\n# -------------------------------------------------------------\n\n# Posteriore ~ Beta(a + k, b + n - k)  -> densità proporzionale a theta^(a+k-1) (1-theta)^(b+n-k-1)\npost_unnorm <- theta^(a + k - 1) * (1 - theta)^(b + n - k - 1)\n\n# Normalizzazione per ottenere pesi che sommano a 1\nw <- post_unnorm / sum(post_unnorm)\n\n# -------------------------------------------------------------\n# PASSAGGIO 3: combinare le predittive condizionate p(tilde y | theta)\n# -------------------------------------------------------------\n# Obiettivo: costruire la pmf predittiva p(tilde y = x | y) \n# per ogni x = 0,...,m come media pesata (sulla griglia di θ) \n# delle pmf condizionate binomiali.\n\n# 1) Definiamo i valori futuri possibili di tilde y\nx_vals <- 0:m\n\n# 2) Inizializziamo una matrice vuota: \n#    - J righe (una per ciascun θ_j della griglia)\n#    - (m+1) colonne (una per ogni valore possibile di x)\npx_given_theta <- matrix(NA_real_, nrow = J, ncol = m + 1)\n\n# 3) Riempiamo la matrice: per ogni θ_j (riga j) e per ogni x (colonna i)\n#    calcoliamo P(tilde y = x | θ_j) = Binomiale(x | m, θ_j)\nfor (j in 1:J) {\n  for (i in 1:(m + 1)) {\n    x <- x_vals[i]\n    px_given_theta[j, i] <- dbinom(x, size = m, prob = theta[j])\n  }\n}\n\n# 4) Combinazione pesata:\n#    p(tilde y = x | y) ≈ somma_j w_j * P(tilde y = x | θ_j).\n#    Per ciascun valore di x (colonna i), facciamo la somma pesata.\npred_pmf <- numeric(m + 1)\nfor (i in 1:(m + 1)) {\n  pred_pmf[i] <- sum(w * px_given_theta[, i])\n}\n\n# Nota didattica:\n# - Ogni colonna della matrice px_given_theta contiene le probabilità condizionate \n#   P(tilde y = x_i | θ_j) per tutti i valori di griglia θ_j.\n# - Moltiplicando riga per riga queste probabilità per i pesi posteriori w_j \n#   e sommando, otteniamo la probabilità predittiva p(tilde y = x_i | y).\n# - In questo modo l'integrale viene approssimato da una somma pesata.\n\n# -------------------------------------------------------------\n# PASSAGGIO 4: Risultato: una pmf su {0,1,...,m}\n# -------------------------------------------------------------\n\npred_df <- data.frame(x = x_vals, p = pred_pmf)\nprint(pred_df)\n#>     x          p\n#> 1   0 0.11391218\n#> 2   1 0.25060680\n#> 3   2 0.27617892\n#> 4   3 0.19946255\n#> 5   4 0.10397516\n#> 6   5 0.04068593\n#> 7   6 0.01205509\n#> 8   7 0.00266151\n#> 9   8 0.00041780\n#> 10  9 0.00004200\n#> 11 10 0.00000205\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsum(pred_df$p)  # dovrebbe essere ~1\n#> [1] 1\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# (Opzionale) campionamento dalla predittiva posteriore approssimata\n# Estrae N valori da {0,...,m} con le probabilità 'p'\nset.seed(123)\nN <- 5000\ntilde_y_samples <- sample(pred_df$x, size = N, replace = TRUE, prob = pred_df$p)\n\n# Controllo: istogramma delle simulazioni vs pmf teorica approssimata\nggplot() +\n  geom_histogram(\n    data = data.frame(x = tilde_y_samples), aes(x = x, y = after_stat(density)),\n    binwidth = 1, breaks = seq(-0.5, m + 0.5, by = 1), fill = \"skyblue\", \n    color = \"black\") +\n  geom_point(data = pred_df, aes(x = x, y = p), pch = 19, cex = 3) + \n  geom_line(data = pred_df, aes(x = x, y = p), lwd = 1.5) + \n  ylim(0, max(pred_df$p) * 1.1) +\n  labs(\n    title = \"Posterior Predictive (grid) – m=10\",\n    x = expression(tilde(y)),\n    y = \"Density\")\n```\n\n::: {.cell-output-display}\n![](03_model_comparison_files/figure-html/unnamed-chunk-4-1.png){fig-align='center' width=85%}\n:::\n:::\n\n\n> **Nota:** il vettore `pred_df$p` è la *pmf* della predittiva posteriore approssimata; da qui si leggono probabilità, si calcolano quantità riassuntive e si può estrarre $\\tilde y$.\n\n**Verifica quando esiste la formula chiusa:** Quando prior e likelihood sono coniugate (Beta + Binomiale), la predittiva è *Beta–Binomiale*. Possiamo usarla solo come verifica didattica:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Confronto con Beta-Binomiale (se applicabile)\na_post <- a + k\nb_post <- b + n - k\n\n# pmf beta-binomial (con funzione base: dbetabinom in VGAM, altrimenti la implementiamo)\ndbetabinom <- function(x, m, a, b) {\n  # Beta-Binomiale: choose(m, x) * Beta(x+a, m-x+b) / Beta(a, b)\n  choose(m, x) * beta(x + a, m - x + b) / beta(a, b)\n}\n\nbb_pmf <- sapply(0:m, function(x) dbetabinom(x, m, a_post, b_post))\ncbind(grid = pred_df$p, beta_binom = bb_pmf)[1:6, ]  # prime 6 righe a confronto\n#>        grid beta_binom\n#> [1,] 0.1139     0.1139\n#> [2,] 0.2506     0.2506\n#> [3,] 0.2762     0.2762\n#> [4,] 0.1995     0.1995\n#> [5,] 0.1040     0.1040\n#> [6,] 0.0407     0.0407\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmax(abs(pred_df$p - bb_pmf))   # lo scarto massimo (dovrebbe essere ~0 con J grande)\n#> [1] 1.68e-15\n```\n:::\n\n\n:::\n\n### Notazione e terminologia\n\n**Notazione:** Useremo talvolta la forma compatta $p(\\cdot \\mid y)$ per indicare la predittiva posteriore del modello. Quando ci servirà evidenziare la previsione *marginale* per una singola osservazione $y_i$, scriveremo:\n\n$$\np(y_i \\mid y) = \\int p(y_i \\mid \\theta)\\, p(\\theta \\mid y)\\, d\\theta,\n$$\ncioè la verosimiglianza $p(y_i\\mid\\theta)$ integrata rispetto alla posteriore $p(\\theta\\mid y)$.\n\n**Idea chiave:** La predittiva posteriore propaga l'incertezza sui parametri alle previsioni. È questo passaggio a rendere le valutazioni predittive coerenti con il principio bayesiano, e quindi utilizzabili nel confronto tra modelli e nella stima di quantità legate alla \"distanza\" dal generatore dei dati.\n\n::: {.callout-note title=\"Mappa concettuale\"}\n\n| Quantità                  | Significato                          | Uso principale                   |\n| ------------------------ | ------------------------------------ | -------------------------------- |\n| $p(y_i \\mid \\theta)$  | Verosimiglianza                      | Calcolo predittivo               |\n| $p(\\theta \\mid y)$     | Distribuzione posteriore             | Ponderazione                     |\n| $p(y_i \\mid y)$       | Predizione bayesiana media           | Log-score, LPPD                  |\n| $p(y_i \\mid y_{-i})$ | Predizione LOO (*leave-one-out*)     | ELPD                             |\n| $p(\\tilde{y} \\mid y)$  | Distribuzione predittiva complessiva | Divergenza KL, confronto modelli |\n:::\n\n\n## Il problema fondamentale della valutazione predittiva\n\nOra che sappiamo come costruire previsioni bayesiane, affrontiamo la domanda centrale: *come valutiamo la qualità di queste previsioni?*\n\n### Il dilemma teorico\n\nQuando costruiamo un modello, vogliamo sapere *quanto bene riesce a predire dati futuri*. In altre parole: se ripetessimo l'esperimento o raccogliessimo nuovi dati, quanto sarebbero vicine le predizioni del modello a quei dati?\n\nPer formalizzare questa idea, distinguiamo tra due distribuzioni:\n\n* *la distribuzione vera dei dati futuri* $p(\\tilde{y})$, che purtroppo non conosciamo,\n* *la distribuzione predittiva del modello* $p(\\tilde{y} \\mid y)$, cioè le predizioni basate sui dati osservati $y$.\n\nL'obiettivo è misurare *quanto $p(\\tilde{y} \\mid y)$ si avvicina a $p(\\tilde{y})$*.\n\n### Una misura di distanza: la divergenza di Kullback–Leibler\n\nLa *divergenza di Kullback–Leibler* (KL) fornisce una misura di questa distanza:\n\n$$\nD_{\\text{KL}}(p \\parallel q) = \\mathbb{E}_{p} \\left[ \\log \\frac{p(\\tilde{y})}{q(\\tilde{y} \\mid y)} \\right].\n$$ {#eq-kl-divergence-def}\nInterpretazione intuitiva:\n\n* se $q$ (il nostro modello) assegna probabilità alte agli stessi eventi che sono probabili in $p$ (la realtà), la distanza sarà piccola,\n* se invece $q$ \"sbaglia bersaglio\", assegnando probabilità alte a eventi che in realtà sono rari, la distanza sarà grande.\n\n::: {.callout-note}\n**Idea chiave.**\nLa KL divergence misura *quanta informazione perdiamo* se usiamo le predizioni del modello $q$ al posto della distribuzione vera $p$.\n:::\n\n\n### Un ostacolo pratico insormontabile\n\nIl problema è che $p(\\tilde{y})$ non lo conosciamo mai: non abbiamo accesso alla \"vera\" distribuzione dei dati futuri. Questa è la sfida fondamentale della validazione predittiva: come possiamo valutare la qualità delle nostre previsioni senza conoscere la verità?\n\nPer questo dobbiamo ricorrere a strategie di approssimazione, come la *validazione incrociata* e criteri predittivi come *ELPD*, che vedremo nelle prossime sezioni.\n\n\n#### Mini-esempio intuitivo\n\nImmagina una moneta truccata che dà *testa* il 70% delle volte.\n\nVogliamo confrontare due modelli:\n\n* *Modello A*: ipotizza una moneta equa ($p = 0.5$),\n* *Modello B*: ipotizza una probabilità leggermente sbilanciata ($p = 0.65$).\n\nSe sapessimo che la probabilità “vera” è $p = 0.7$, sarebbe chiaro che il Modello B è più vicino alla realtà. La divergenza di Kullback–Leibler serve proprio a quantificare *quanta informazione perdiamo* quando ci affidiamo a un modello meno accurato (come A) invece che a uno più vicino alla verità (come B).\n\nIl punto cruciale è che *nella pratica* non conosciamo mai la probabilità vera della moneta. Abbiamo soltanto i dati osservati, cioè gli esiti dei lanci. Per decidere quale modello predice meglio dobbiamo quindi basarci sui dati disponibili: è qui che entrano in gioco i metodi di confronto predittivo che studieremo.\n\n\n## Il log-score: misurare l'accuratezza predittiva punto per punto {#sec-logscore}\n\nAbbiamo definito la distribuzione predittiva posteriore e il problema teorico della valutazione. Ora introduciamo il primo strumento pratico: il *log-score*.\n\n### La domanda di base\n\nPer ogni osservazione nei nostri dati, vogliamo sapere: *quanto il nostro modello considerava plausibile questo specifico risultato?* Il log-score risponde proprio a questa domanda.\n\n### Definizione formale\n\nIl *log-score* per un'osservazione $y_i$ è semplicemente il logaritmo della probabilità che il modello assegnava a quell'osservazione:\n\n$$\n\\text{Log-score}(y_i) = \\log p(y_i \\mid y) ,\n$$ {#eq-log-score-def}\ndove $p(y_i \\mid y)$ è la distribuzione predittiva posteriore che abbiamo appena imparato a calcolare:\n\n$$\np(y_i \\mid y) = \\int p(y_i \\mid \\theta)\\, p(\\theta \\mid y)\\, d\\theta .\n$$\n\n### Interpretazione: \"scommettere\" sui dati\n\nIl log-score può essere interpretato come quanto il modello avrebbe \"scommesso\" su quel particolare risultato:\n\n* *se il modello assegna *alta probabilità* a $y_i$*: $p(y_i \\mid y) \\approx 1$, quindi $\\log p(y_i \\mid y) \\approx 0$ (buono);\n* *se il modello assegna *bassa probabilità* a $y_i$*: $p(y_i \\mid y) \\approx 0$, quindi $\\log p(y_i \\mid y) \\ll 0$ (molto negativo, scarso).\n\n\n::: {.callout-note}\n**Perché il logaritmo?**  \nIl logaritmo trasforma prodotti di probabilità in somme. Così possiamo sommare contributi *punto per punto* dei dati invece di moltiplicarli; inoltre stabilizza i numeri molto piccoli tipici delle verosimiglianze.\n:::\n\n\n### Dal singolo dato al punteggio totale\n\nPer avere una visione complessiva della performance del modello, sommiamo i log-score su tutte le osservazioni:\n\n$$\nS = \\sum_{i=1}^n \\log p(y_i \\mid y) .\n$$ {#eq-log-score-sum-def}\nPiù $S$ è alto (meno negativo), più il modello \"scommette\" bene sui dati osservati (*in-sample*).\n\n\n### Due filosofie a confronto: parametri fissi vs. incerti\n\nIl calcolo del log-score può seguire due approcci concettualmente diversi, che riflettono due filosofie statistiche diverse.\n\n\n#### Approccio classico: parametri fissi\n\nNell'impostazione frequentista classica, usiamo una stima puntuale dei parametri (ad es. Massima Verosimiglianza o MAP) e ignoriamo l'incertezza:\n\n$$\n\\text{Log-score classico} = \\log p(y_i \\mid \\hat{\\theta}).\n$$\n\n\n#### Approccio bayesiano: gestione dell'incertezza sui parametri\n\nNell’approccio bayesiano non fissiamo i parametri a un singolo valore stimato, ma li trattiamo come *incerti*. Questo significa che, invece di calcolare la verosimiglianza con un \\$\\hat{\\theta}\\$, “mescoliamo” tutte le verosimiglianze possibili, pesandole in base alla loro plausibilità a posteriori:\n\n$$\n\\begin{align}\n\\text{Log-score bayesiano} &= \\log p(y_i \\mid y) \\\\\n&= \\log \\int p(y_i \\mid \\theta)\\, p(\\theta \\mid y)\\, d\\theta .\n\\end{align}\n$$ {#eq-integral-p-h-mid-yi}\n\nIn altre parole, la probabilità predittiva di $y_i$ non dipende da un solo $\\theta$, ma dalla *media delle predizioni condizionate su tutti i valori plausibili* dei parametri.\n\n::: {.callout-note}\n**Differenza chiave**  \n- L’approccio frequentista chiede: *“Quanto sono plausibili i dati se i parametri valgono esattamente $\\hat{\\theta}$?”*  \n- L’approccio bayesiano chiede: *“Quanto sono plausibili i dati, in media, considerando tutti i valori di $\\theta$ compatibili con i dati osservati?”*  \n\nLa seconda prospettiva è più onesta perché riconosce l’incertezza sui parametri.\n:::\n\n\n### Implementazione pratica con il metodo MCMC\n\nL'integrale nell'nell'@eq-integral-p-h-mid-yi raramente ha una soluzione analitica (cioè non si può calcolare con una formula esatta). Possiamo però stimarlo in modo pratico ed efficiente utilizzando i campioni generati da un algoritmo MCMC (Markov Chain Monte Carlo).\n\nSupponiamo di avere una serie di campioni di parametri, $\\theta^{(1)},\\dots,\\theta^{(S)}$, estratti dalla distribuzione a posteriori $p(\\theta\\mid y)$. Il procedimento per approssimare la probabilità predittiva si articola in due semplici passi:\n\n#### Passo 1: calcolare la verosimiglianza per ogni campione\n\nPer ogni set di parametri $\\theta^{(s)}$ che abbiamo campionato, calcoliamo la probabilità (verosimiglianza) di osservare il dato $y_i$ sotto quei parametri:\n\n$$\np\\bigl(y\\_i \\mid \\theta^{(s)}\\bigr).\n$$\n\nFare questo per tutti i campioni $S$ ci fornisce un insieme di valori:\n\n$$\n\\bigl\\{\\, p(y\\_i \\mid \\theta^{(1)}),\\; p(y\\_i \\mid \\theta^{(2)}),\\; \\dots,\\; p(y\\_i \\mid \\theta^{(S)}) \\,\\bigr\\}\n$$\nQuesta collezione rappresenta come la plausibilità del dato $y_i$ cambi al variare dei parametri, ponderata per la loro probabilità a posteriori.\n\n#### Passo 2: calcolare la media dei valori ottenuti\n\nLa probabilità predittiva per $y_i$ (che tiene conto di tutta l'incertezza sui parametri) è approssimata semplicemente calcolando la media aritmetica dell'insieme di valori ottenuti nel passo precedente:\n\n$$\np(y_i \\mid y) \\;\\approx\\; \\frac{1}{S}\\sum_{s=1}^S p\\bigl(y_i \\mid \\theta^{(s)}\\bigr).\n$${#eq-mcmc-posterior-parameter-distr}\n\nIl risultato è un *singolo valore numerico* (uno scalare) che sintetizza in una previsione probabilistica tutto ciò che abbiamo appreso sull'incertezza dei parametri del modello.\n \n\n### La LPPD: una misura bayesiana di bontà della previsione\n\nPer valutare la capacità predittiva dell'intero modello su tutti i dati, ripetiamo il procedimento per ogni osservazione $y_i$ e procediamo così:\n\n1.  per ogni osservazione $y_i$, calcoliamo la sua probabilità predittiva media $p(y_i \\mid y)$;\n2.  prendiamo il logaritmo naturale di questa probabilità. (Usiamo il logaritmo per motivi computazionali e perché trasforma prodotti in somme);\n3.  sommiamo i logaritmi di tutte le $n$ osservazioni.\n\nIl risultato di questo processo è la *Log Pointwise Predictive Density (LPPD)*:\n\n$$\n\\text{LPPD} = \\sum_{i=1}^n \\log \\left[ \\frac{1}{S} \\sum_{s=1}^S p\\bigl(y_i \\mid \\theta^{(s)}\\bigr) \\right].\n$${#eq-lppd-def}\n\n**Confronto e Sintesi:**\n\n*   Il *log-score classico* (usato nella statistica frequentista) valuta la previsione utilizzando un unico valore stimato dei parametri (ad esempio, la stima di massima verosimiglianza $\\hat{\\theta}$). Questo ignora completamente l'incertezza esistente sulla stima dei parametri.\n*   La *LPPD* bayesiana compie la stessa operazione fondamentale, ma in modo più robusto: invece di usare un singolo valore dei parametri, *media le previsioni* su tutte le migliaia di valori plausibili dei parametri campionati dalla distribuzione a posteriori. In questo modo, la misura di bontà predittiva incorpora in modo naturale tutta l'incertezza del modello.\n\n\n### Il problema nascosto: overfitting in-sample\n\nLa LPPD è calcolata sugli stessi dati usati per stimare il modello: modelli molto flessibili possono \"scommettere bene\" anche sul rumore, gonfiando la LPPD *in-sample*.  \n\n**Analogia:** È come valutare uno studente facendogli ripetere gli stessi esercizi che ha già risolto durante lo studio. Otterrà un punteggio alto, ma non sappiamo se sarebbe altrettanto bravo con problemi nuovi.\n\nPer valutare la capacità di generalizzazione, serve una stima *out-of-sample*. Nelle prossime sezioni introdurremo la validazione incrociata *leave-one-out* (LOO-CV) e l'*ELPD* (*Expected Log Pointwise Predictive Density*), che forniscono una versione \"fuori campione\" della LPPD per il confronto predittivo tra modelli.\n\n::: {.callout-note collapse=true title=\"Esempio pratico del calcolo LPPD\"}\nConsideriamo un singolo dato $y_i = 3$ successi su $n=5$ tentativi (Binomiale).  Abbiamo tre valori plausibili per $\\theta$ dalla posterior, con pesi didattici $w^{(s)}$ (nella pratica MCMC i pesi sono uguali):\n\n- $\\theta^{(1)}=0.3$ con $w^{(1)}=0.2$  \n- $\\theta^{(2)}=0.5$ con $w^{(2)}=0.5$  \n- $\\theta^{(3)}=0.7$ con $w^{(3)}=0.3$\n\nPer ogni campione $\\theta^{(s)}$ calcoliamo $p(y_i \\mid \\theta^{(s)})$, otteniamo la *collezione di likelihood* $\\{p(y_i\\mid \\theta^{(s)})\\}_{s=1}^S$, poi facciamo la media pesata (eq. @eq-mcmc-posterior-parameter-distr) per ottenere $p(y_i\\mid y)$, e infine il *log-score* $\\log p(y_i\\mid y)$ (eq. @eq-log-score-def).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Dato osservato (un solo punto)\ny_i  <- 3\nn_i  <- 5\n\n# \"Campioni\" posteriori (qui pochi e con pesi espliciti per chiarezza didattica)\ntheta_vals        <- c(0.3, 0.5, 0.7)      # θ^(1), θ^(2), θ^(3)\nposterior_weights <- c(0.2, 0.5, 0.3)      # w^(1), w^(2), w^(3); in MCMC tipicamente uguali\n\n# (1) Likelihood punto-per-punto: p(y_i | θ^(s))\nlikelihoods <- dbinom(y_i, size = n_i, prob = theta_vals)\nlikelihoods  # questa è la collezione { p(y_i | θ^(s)) }_s\n#> [1] 0.132 0.312 0.309\n\n# (2) Media (pesata) sulle likelihood ⇒ p(y_i | y) ≈ Σ_s w^(s) p(y_i | θ^(s))\np_yi_given_y <- sum(posterior_weights * likelihoods)\n\n# (3) Log-score (per un solo dato coincide con la LPPD del singolo punto)\nlog_score_i <- log(p_yi_given_y)\n\n# Stampa riassuntiva con notazione coerente\ncat(\"Campioni θ^{(s)}:        \", theta_vals, \"\\n\")\n#> Campioni θ^{(s)}:         0.3 0.5 0.7\ncat(\"Likelihood p(y_i|θ^{(s)}):\", round(likelihoods, 4), \"\\n\")\n#> Likelihood p(y_i|θ^{(s)}): 0.132 0.312 0.309\ncat(\"p(y_i|y) (media pesata):  \", round(p_yi_given_y, 4), \"\\n\")\n#> p(y_i|y) (media pesata):   0.275\ncat(\"log p(y_i|y):             \", round(log_score_i, 4), \"\\n\")\n#> log p(y_i|y):              -1.29\n```\n:::\n\n\n**Nota didattica:** Nella pratica con MCMC i pesi sono uguali, $w^{(s)}=\\tfrac{1}{S}$, quindi $p(y_i\\mid y) \\approx \\tfrac{1}{S}\\sum_{s=1}^S p(y_i\\mid \\theta^{(s)})$ (@eq-mcmc-posterior-parameter-distr). Con più osservazioni $\\{y_i\\}_{i=1}^n$, la *LPPD* è la somma dei log-score punto-per-punto (@eq-lppd-def).\n:::\n\n## La svolta: dall'adattamento alla generalizzazione\n\n### Il problema dell’overfitting spiegato\n\nImmagina di voler valutare la capacità di uno studente di *riconoscere emozioni nei volti*.\n\n1. *Scenario A:* lo testi sempre con le *stesse fotografie* che ha già visto molte volte durante l’allenamento.\n2. *Scenario B:* lo testi con *nuove fotografie* di persone mai viste prima.\n\nNel primo caso, lo studente probabilmente avrà un punteggio molto alto, ma non sapremo se ha davvero imparato a riconoscere le emozioni o se si limita a ricordare quelle immagini specifiche. Il secondo scenario, invece, è più onesto: misura la capacità di generalizzare la competenza a stimoli nuovi.\n\nLo stesso accade con i modelli statistici.\n\n* La *LPPD* corrisponde allo *Scenario A*: valuta il modello sugli stessi dati usati per adattarlo, rischiando di dare un’illusione di performance eccellente.\n* Per sapere se il modello sa davvero “generalizzare”, serve testarlo come nello *Scenario B*: con dati nuovi o tramite tecniche di validazione incrociata.\n\n\n### Guardare oltre i dati osservati\n\nQuando valutiamo un modello, non ci basta sapere *quanto bene spiega i dati che ha già visto*.\nLa vera domanda è: *quanto bene predirebbe dati nuovi, mai osservati?*\n\nLa *Expected Log Predictive Density (ELPD)* risponde a questa domanda. La logica è la stessa della LPPD, ma con una differenza cruciale: la previsione di ogni osservazione $y_i$ viene fatta *senza usare $y_i$ per stimare il modello*. Questa tecnica si chiama *Leave-One-Out (LOO)*:\n\n$$\n\\text{ELPD} = \\sum_{i=1}^n \\log p(y_i \\mid y_{-i}),\n$$ {#eq-elpd-def}\ndove $y_{-i}$ indica il dataset a cui è stata tolta l’osservazione $i$.\n\n\n#### Un esempio concreto per chiarire la differenza\n\nImmagina di voler costruire un modello che predice i *punteggi di memoria a breve termine* degli studenti a partire dal loro livello di concentrazione.\n\n- Con la *LPPD*, il modello viene valutato sugli stessi studenti che sono serviti per stimarlo. È come dire: *“quanto bene il modello spiega questi dati noti?”*.  \n- Con la *ELPD*, invece, ogni volta togliamo uno studente dal campione, stimiamo il modello sugli altri e proviamo a predire il punteggio di quello escluso. È come chiedere: *“quanto bene il modello predirebbe un nuovo studente, mai visto prima?”*.\n\n#### Procedura passo per passo\n\n1. Prendiamo il primo studente ed escludiamolo dal dataset.  \n2. Adattiamo il modello usando i dati dei rimanenti studenti.  \n3. Prediciamo il punteggio di memoria dello studente escluso.  \n4. Ripetiamo lo stesso procedimento per ogni studente, uno alla volta.  \n5. Sommiamo tutti i log-score ottenuti: questo è l’ELPD.  \n\n\n## Il collegamento con la divergenza KL\n\n### La teoria che unifica tutto\n\nAbbiamo visto che l'ELPD fornisce una misura empirica della capacità predittiva di un modello. Esiste, tuttavia, una giustificazione teorica profonda e unificante che spiega il motivo per cui massimizzare l'ELPD è il principio corretto per la selezione dei modelli. Questa giustificazione poggia sul concetto di *divergenza di Kullback-Leibler (KL)*.\n\n#### Cosa misura la divergenza KL?\n\nLa divergenza KL, indicata come $D_{\\text{KL}}$, misura la \"distanza\" informazionale tra la distribuzione vera dei dati, $p(\\tilde{y})$ (la realtà che vogliamo catturare), e la distribuzione predittiva del nostro modello, $q(\\tilde{y} \\mid y)$ (la nostra approssimazione). È definita come:\n\n$$\nD_{\\text{KL}}(p \\parallel q) = \\mathbb{E}_p \\left[ \\log \\frac{p(\\tilde{y})}{q(\\tilde{y} \\mid y)} \\right],\n$$\ndove l'aspettativa $\\mathbb{E}_p$ è calcolata rispetto alla distribuzione vera $p(\\tilde{y})$.\n\n#### Scomponiamo la divergenza KL\n\nPer comprendere a fondo, espandiamo la definizione:\n\n$$\nD_{\\text{KL}}(p \\parallel q) = \\underbrace{\\mathbb{E}_p[\\log p(\\tilde{y})]}_{\\text{(1) Entropia}} - \\underbrace{\\mathbb{E}_p[\\log q(\\tilde{y} \\mid y)]}_{\\text{(2) Accuratezza predittiva}}.\n$$ {#eq-kl-decomposition}\n\nAnalizziamo i due termini:\n\n1.  *$\\mathbb{E}_p[\\log p(\\tilde{y})]$ (Entropia)*: Rappresenta il contenuto informativo intrinseco della distribuzione vera. È una quantità fissa, immutabile e, soprattutto, *indipendente dal modello* che stiamo considerando. È una costante.\n2.  *$-\\mathbb{E}_p[\\log q(\\tilde{y} \\mid y)]$ (Log-verosimiglianza attesa)*: Questo è il termine cruciale. Misura quanto è buona la nostra distribuzione predittiva $q$ nel prevedere nuovi dati provenienti dalla vera distribuzione $p$. Nota: questo è esattamente l'opposto della quantità che *stimiamo con l'ELPD* $(\\sum \\log q(\\tilde{y} \\mid y))$.\n\n#### Il collegamento fondamentale\n\nPoiché il primo termine dell'@eq-kl-decomposition è una costante, *minimizzare la divergenza KL $D_{\\text{KL}}(p \\parallel q)$ equivale esattamente a massimizzare il secondo termine*, ovvero l'accuratezza predittiva attesa. Questo risultato si traduce in una regola pratica potentissima per il confronto tra modelli. Date due distribuzioni predittive, $q_A$ e $q_B$, la differenza nelle loro divergenze KL è:\n\n$$\n\\begin{aligned}\nD_{\\text{KL}}(p \\parallel q_A) - D_{\\text{KL}}(p \\parallel q_B) &= \\left( \\cancel{\\mathbb{E}_p[\\log p(\\tilde{y})]} - \\mathbb{E}_p[\\log q_A(\\tilde{y} \\mid y)] \\right) \\notag\\\\\n&\\qquad - \\left( \\cancel{\\mathbb{E}_p[\\log p(\\tilde{y})]} - \\mathbb{E}_p[\\log q_B(\\tilde{y} \\mid y)] \\right) \\\\\n&= \\mathbb{E}_p[\\log q_B(\\tilde{y} \\mid y)] - \\mathbb{E}_p[\\log q_A(\\tilde{y} \\mid y)] \\\\\n&= \\text{ELPD}(q_B) - \\text{ELPD}(q_A)\n\\end{aligned}\n$$\ndove abbiamo cancellato il termine entropia costante.\n\n#### Conclusione teorica fondamentale\n\nIl risultato precedente ci porta alla conclusione chiave di tutta la teoria:\n\n$$\n\\text{Massimizzare l'ELPD} \\;\\; \\equiv \\;\\; \\text{Minimizzare la divergenza KL dalla verità}.\n$$\nIn altre parole, quando preferiamo il modello con l'ELPD più alto, non stiamo solo seguendo un criterio empirico. Stiamo scegliendo consapevolmente il modello la cui distribuzione predittiva è, in media, *più vicina alla realtà sottostante* in senso informazionale. Questo principio unifica la teoria dell'informazione con la pratica della valutazione e selezione dei modelli predittivi.\n\n\n::: {.callout-note collapse=true title=\"Esempio: collegamento ELPD-KL in pratica\"}\n\nVogliamo confrontare due modelli predittivi per il numero di \"teste\" in $n=10$ lanci. Supponiamo che\n\n- la **distribuzione vera** è $p(y)=\\text{Binom}(n=10,\\;p=0.6)$,\n- il **modello candidato** prevede $q(y)=\\text{Binom}(n=10,\\;q=0.5)$.\n\nL'*ELPD* di un modello è l'aspettativa, rispetto alla distribuzione vera $p$, del *log-score* del modello: $\\mathrm{ELPD}(q)=\\mathbb{E}_{p}[\\log q(Y)]$. Nel caso discreto, l'aspettativa diventa una somma su tutti i possibili valori $y=0,\\dots,n$.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Parametri del problema\nn <- 10          # numero di lanci\np <- 0.6         # probabilità vera di \"testa\"\nq <- 0.5         # probabilità ipotizzata dal modello candidato\n\n# 1) Supporto dei possibili esiti\ny_vals <- 0:n\n\n# 2) Distribuzione vera p(y) su tutto il supporto\np_y <- dbinom(y_vals, size = n, prob = p)\n\n# 3) Log-predittiva del modello candidato q su tutto il supporto\nlog_q_y <- log(dbinom(y_vals, size = n, prob = q))\n\n# 4) ELPD del modello candidato: somma dei log q(y) pesati da p(y)\nelpd_q <- sum(p_y * log_q_y)\n\n# 5) \"Modello vero\": usa q = p. Log-predittiva del modello vero\nlog_p_y <- log(dbinom(y_vals, size = n, prob = p))\n\n# 6) ELPD del modello vero: somma dei log p(y) pesati da p(y)\nelpd_p <- sum(p_y * log_p_y)\n\n# 7) Divergenza KL tra p e q: somma p(y) * log [p(y)/q(y)]\nkl_pq <- sum(p_y * (log_p_y - log_q_y))\n\ncat(sprintf(\"ELPD modello candidato (q=0.5): %.4f\\n\", elpd_q))\n#> ELPD modello candidato (q=0.5): -2.0549\ncat(sprintf(\"ELPD modello vero      (q=0.6): %.4f\\n\", elpd_p))\n#> ELPD modello vero      (q=0.6): -1.8536\ncat(sprintf(\"Differenza ELPD (vero - candidato): %.4f\\n\", elpd_p - elpd_q))\n#> Differenza ELPD (vero - candidato): 0.2014\ncat(sprintf(\"KL(p || q): %.4f\\n\", kl_pq))\n#> KL(p || q): 0.2014\n```\n:::\n\n\n**Cosa stiamo verificando?**\n\n1. $\\mathrm{ELPD}(q)=\\sum_y p(y)\\log q(y)$ è *più basso* (più negativo) del valore ottenuto dal modello vero $\\mathrm{ELPD}(p)=\\sum_y p(y)\\log p(y)$.\n   → Il modello con $q=0.6$ è *più predittivo* di quello con $q=0.5$.\n\n2. La differenza tra i due ELPD è *uguale* (vicina numericamente) alla divergenza di Kullback–Leibler:\n\n$$\n\\begin{align}\n\\mathrm{ELPD}(p)-\\mathrm{ELPD}(q) &= \\sum_y p(y)\\big[\\log p(y)-\\log q(y)\\big] \\notag\\\\\n&= D_{\\mathrm{KL}}(p\\|q)\\;>\\;0.\n\\end{align}\n$$\nQuesto mostra algebricamente e numericamente il legame: *massimizzare l'ELPD equivale a minimizzare la divergenza KL*.\n\n**In pratica:** In questo esempio abbiamo potuto calcolare l'ELPD *vero* perché conoscevamo l'intera distribuzione generatrice $p(y)$ e potevamo integrare esattamente. Nella realtà, $p(y)$ è sconosciuta: disponiamo solo di un campione osservato. In questi casi stimiamo l'ELPD *empiricamente*, ad esempio con la *Leave-One-Out Cross-Validation* (LOO-CV), che sostituisce l'aspettativa rispetto a $p$ con una media sui dati raccolti, lasciando fuori una osservazione alla volta.\n:::\n\n::: {.callout-note}\n**Collegamento chiave.**  \n\nL'ELPD è una stima empirica (con segno cambiato) della divergenza di Kullback–Leibler.  Più alto è l'ELPD, migliore è la capacità predittiva del modello.\n:::\n\n\n## Stimare l'ELPD nella pratica: la Leave-One-Out Cross-Validation\n\nAbbiamo chiarito che l’ELPD è la misura ideale della bontà predittiva di un modello, perché è direttamente collegata alla divergenza KL. Il problema è che, per definizione, richiede un’aspettativa rispetto alla vera distribuzione dei dati futuri $p(\\tilde{y})$, che non conosciamo mai.\n\n*Come possiamo allora stimarlo?* La soluzione più usata è la *Leave-One-Out Cross-Validation* (LOO-CV), che ci permette di avvicinarci all’ELPD teorico usando soltanto i dati osservati.\n\n\n### L’idea alla base della LOO-CV\n\nIl principio è semplice: trattare ogni osservazione del dataset come se fosse “nuova” e verificare se il modello, addestrato sui dati rimanenti, riesce a prevederla.\n\nIl procedimento è questo:\n\n1. Si prende un’osservazione $y_i$.\n2. La si rimuove temporaneamente dal dataset.\n3. Si stima il modello sui dati rimanenti $y_{-i}$.\n4. Si calcola la densità predittiva che il modello assegna al dato escluso: $p(y\\_i \\mid y_{-i})$.\n5. Si ripete per tutte le osservazioni e si sommano i logaritmi.\n\nIn formula:\n\n$$\n\\text{ELPD}_{\\text{LOO}} = \\sum_{i=1}^n \\log p(y_i \\mid y_{-i}) .\n$$ {#eq-elpd-loo}\n\nCosì otteniamo una stima *out-of-sample*: il modello viene valutato su dati che non ha mai visto.\n\n\n### Perché funziona\n\nLa LOO-CV funziona perché sostituisce l’aspettativa teorica rispetto a $p(\\tilde{y})$ con una media empirica sulle osservazioni reali. Ogni $y_i$ viene trattata come un nuovo dato proveniente da $p$, e la media dei log-score fuori campione fornisce una stima della capacità predittiva attesa:\n\n$$\n\\text{ELPD}_{\\text{LOO}} \\approx \\mathbb{E}_p[\\log q(\\tilde{y}\\mid y)] .\n$$ {#eq-elpd-loo-interpretation}\n\n\n### Confrontare i modelli con LOO-CV\n\nUna volta stimato l’ELPD-LOO, possiamo confrontare due modelli calcolando la differenza:\n\n$$\n\\Delta \\text{ELPD} = \\text{ELPD}_{\\text{LOO}}(M_1) - \\text{ELPD}_{\\text{LOO}}(M_2).\n$$ {#eq-delta-elpd}\n\nSe la differenza è positiva, il modello $M_1$ ha una distribuzione predittiva più vicina alla realtà di quella di $M_2$. \n\nÈ utile stimare anche un errore standard della differenza. Come regola empirica, una differenza di almeno *due volte l’SE* indica un vantaggio credibile di un modello sull’altro.\n\n\n### Overfitting e vantaggio della LOO-CV\n\nSe valutassimo un modello sugli stessi dati usati per addestrarlo, la sua performance apparirebbe gonfiata (*overfitting*). La LOO-CV aggira questo problema: ogni osservazione viene valutata solo con modelli che non l’hanno vista. Il punteggio ottenuto è quindi una misura più realistica della capacità di generalizzare a nuovi dati.\n\n\n### PSIS-LOO: la scorciatoia pratica\n\nUn limite della LOO tradizionale è che richiederebbe di riadattare il modello $n$ volte, cosa spesso impraticabile. Per questo oggi si usa il metodo *Pareto-Smoothed Importance Sampling* (PSIS-LOO), che consente di stimare l’ELPD-LOO a partire da un unico adattamento del modello, sfruttando i campioni MCMC.\n\nIn R, tutto ciò è implementato nel pacchetto `loo`, già integrato in `brms` e `rstanarm`, attraverso funzioni come `loo()` e `loo_compare()`. Oltre ai valori di ELPD, queste funzioni forniscono anche diagnostiche (le *Pareto k*) per capire se la stima è affidabile.\n\n\n#### In sintesi\n\n* L’ELPD misura la capacità predittiva del modello su dati futuri.\n* Non conoscendo la distribuzione vera, usiamo la LOO-CV per stimarlo.\n* La differenza di ELPD-LOO tra modelli approssima la differenza nelle loro divergenze KL.\n* PSIS-LOO rende il calcolo efficiente anche per modelli complessi.\n* La regola pratica: preferire il modello con *ELPD-LOO più alto*, tenendo conto anche della sua semplicità e interpretabilità.\n\n\n::: {.callout-note collapse=true title=\"Esempio: confronto ELPD-LOO tra due modelli\"}\nQuesto esempio mostra come passare dalla definizione teorica dell'ELPD alla stima pratica via Leave-One-Out, usando un caso elementare Beta–Bernoulli.\n\n**Dati:** Cinque prove indipendenti: $y=\\{1,1,1,0,1\\}$ (quattro \"successi\", un \"insuccesso\").\n\n**Modello A (Bayesiano adattato ai dati):** Bernoulli$(\\theta)$ con prior $\\theta\\sim \\text{Beta}(1,1)$ (uninformativa).\nPer LOO:\n* per ogni $i$, escludiamo $y_i$;\n* calcoliamo la posteriore $\\theta \\mid y_{-i} \\sim \\text{Beta}(1+s_{-i},\\,1+n_{-i}-s_{-i})$, dove $s_{-i}$ è il numero di successi tra i $n-1$ rimanenti;\n* calcoliamo la probabilità predittiva per $y_i$.\n\n**Modello B (di confronto):** Moneta equa fissa ($q=0.5$): la predittiva è sempre $0.5$, indipendentemente dai dati.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Dati\ny <- c(1, 1, 1, 0, 1)\nn <- length(y)\n\n# Log-predittiva LOO per Modello A (Beta(1,1) + Bernoulli)\nloo_log_pred_beta <- function(i, y, a0 = 1, b0 = 1) {\n  yi <- y[i]\n  s_minus <- sum(y) - yi\n  n_minus <- n - 1\n  alpha <- a0 + s_minus\n  beta  <- b0 + (n_minus - s_minus)\n  p1 <- alpha / (alpha + beta)\n  p  <- if (yi == 1) p1 else (1 - p1)\n  log(p)\n}\n\n# Log-predittive punto-per-punto\nlp_beta  <- sapply(seq_along(y), loo_log_pred_beta, y = y)\nlp_fixed <- rep(log(0.5), n)\n\n# ELPD-LOO\nelpd_beta  <- sum(lp_beta)\nelpd_fixed <- sum(lp_fixed)\n\n# Differenza e SE\ndiff_pt <- lp_beta - lp_fixed\nse_diff <- sqrt(n * var(diff_pt))\n\n# Tabella riassuntiva\nres <- data.frame(\n  i = 1:n, y = y,\n  lp_beta = round(lp_beta, 6),\n  lp_fixed = round(lp_fixed, 6),\n  diff = round(diff_pt, 6)\n)\nprint(res)\n#>   i y lp_beta lp_fixed   diff\n#> 1 1 1  -0.405   -0.693  0.288\n#> 2 2 1  -0.405   -0.693  0.288\n#> 3 3 1  -0.405   -0.693  0.288\n#> 4 4 0  -1.792   -0.693 -1.099\n#> 5 5 1  -0.405   -0.693  0.288\ncat(sprintf(\"\\nELPD-LOO Modello A: %.6f\\n\", elpd_beta))\n#> \n#> ELPD-LOO Modello A: -3.413620\ncat(sprintf(\"ELPD-LOO Modello B: %.6f\\n\", elpd_fixed))\n#> ELPD-LOO Modello B: -3.465736\ncat(sprintf(\"Differenza (A-B)  : %.6f\\n\", elpd_beta - elpd_fixed))\n#> Differenza (A-B)  : 0.052116\ncat(sprintf(\"SE differenza     : %.6f\\n\", se_diff))\n#> SE differenza     : 1.386294\n```\n:::\n\n\n**Interpretazione:**\n\n* Ogni riga della tabella mostra la log-predittiva fuori campione per entrambi i modelli\n* In un campione con 4 successi su 5, il Modello A assegna più di 0.5 di probabilità ai successi, e meno di 0.5 all'unico insuccesso\n* L'ELPD-LOO di A può risultare leggermente più alto di quello di B, ma l'errore standard è grande perché $n$ è piccolo\n\n> **Regola pratica:** una differenza $|\\Delta \\text{ELPD}|$ di almeno 2 volte l'SE fornisce un'indicazione più affidabile di superiorità del modello. In esempi così piccoli l'obiettivo è puramente didattico: capire come si calcola e cosa significa.\n:::\n\n\n::: {.callout-note collapse=true title=\"In pratica: stimare e confrontare l'ELPD-LOO\"}\n**Concetto chiave**\n\n* L’ELPD valuta la capacità predittiva su dati non visti.\n* La LOO-CV lo stima in modo efficiente con PSIS-LOO.\n\n**Strumenti**\n\n* Funzione `loo()` del pacchetto *loo*, integrata in `brms` e `rstanarm`.\n* Diagnostica con *Pareto k*, confronto con `loo_compare()`.\n\n**Workflow tipico in R**\n\n1. Adattare ogni modello (`brm()` o `stan_glm()`).\n2. Estrarre `log_lik()` e calcolare `loo()`.\n3. Confrontare modelli con `loo_compare()`.\n\n**Decisione**\n\n* Preferire l’ELPD-LOO più alto.\n* Differenza ≥ 2×SE → indicazione di vantaggio sostanziale.\n* Valutare anche semplicità e interpretabilità.\n:::\n\n\n\n## Criteri di informazione\n\nOltre alla convalida incrociata Leave-One-Out, la statistica offre altri strumenti per stimare la qualità predittiva di un modello senza conoscere la distribuzione vera dei dati. Molti di questi metodi affondano le loro radici teoriche nel concetto di divergenza di Kullback-Leibler, che misura la distanza tra la distribuzione generatrice dei dati e quella stimata dal nostro modello.\n\nL'obiettivo comune è valutare la capacità di un modello di generalizzare, ovvero di fare buone previsioni su dati non osservati, senza farsi trarre in inganno dall'overfitting. Tutti i criteri seguono una logica simile, bilanciando due componenti: una misura della *bontà di adattamento* ai dati e una *penalità per la complessità* del modello stesso. I vari criteri si distinguono proprio per come definiscono queste due componenti e per le assunzioni su cui si basano.\n\n### Una panoramica dei criteri principali\n\nL’**AIC** (Akaike Information Criterion) approssima la distanza di Kullback-Leibler utilizzando la verosimiglianza massimizzata e applica una penalità semplice, proporzionale al numero di parametri. È un criterio veloce e ampiamente utilizzato, particolarmente utile per modelli regolari con campioni non troppo piccoli e privi di struttura gerarchica.\n\nIl **BIC** (Bayesian Information Criterion) segue una logica simile all'AIC, ma introduce una penalità per la complessità che cresce all'aumentare della dimensione del campione. Questo lo porta tendenzialmente a preferire modelli più parsimoniosi quando il numero di osservazioni è grande e, sotto specifiche ipotesi, può essere collegato alla verosimiglianza marginale.\n\nIl **WAIC** (Widely Applicable Information Criterion) rappresenta una versione pienamente bayesiana. Utilizza l'intera distribuzione predittiva a posteriori per valutare il fit e stima una penalità per la complessità effettiva del modello, che può differire dal semplice numero di parametri. È particolarmente adatto per modelli complessi o non regolari ed è concettualmente molto vicino alla stima LOO.\n\nInfine, il **LOO-CV** (Leave-One-Out Cross-Validation), specialmente nella sua efficiente implementazione PSIS-LOO, stima direttamente l'Expected Log Predictive Density (ELPD) escludendo un dato alla volta. È spesso considerato il gold standard per il confronto predittivo nell'ambito della modellazione bayesiana, grazie alla sua robustezza e alle utili diagnostiche che fornisce.\n\n#### Come orientarsi nella scelta\n\nUna regola pratica è che se l'obiettivo principale è la previsione fuori campione in un contesto bayesiano, il PSIS-LOO o il WAIC sono generalmente da preferire ad AIC e BIC. In un approccio frequentista classico, con modelli regolari e campioni di dimensioni medio-grandi, l'AIC rimane un buon compromesso, mentre il BIC può essere più appropriato quando si desidera enfatizzare la parsimonia.\n\nPer modelli bayesiani con obiettivo predittivo e dati reali (spesso non iid o gerarchici), il PSIS-LOO è la prima scelta, con il WAIC utile come riscontro. Con campioni piccoli, strutture complesse o unità dipendenti, è bene evitare criteri puramente asintotici come AIC e BIC, preferendo invece LOO o definendo con attenzione l'unità di esclusione (ad esempio, per soggetto o per gruppo). Nei modelli gerarchici o multilivello, LOO e WAIC possono essere applicati in modo coerente, prestando attenzione a non escludere singole osservazioni se queste non sono indipendenti, ma piuttosto interi cluster.\n\n#### Errori comuni e best practice\n\nUn errore frequente è utilizzare il Mean Squared Error (MSE) sul campione di addestramento come metro di giudizio, poiché questo valore non penalizza la complessità e tende quindi a favorire modelli eccessivamente flessibili e soggetti a overfitting. Allo stesso modo, è importante ricordare che AIC e BIC si basano su stime puntuali (MLE o MAP) e non catturano l'incertezza completa sui parametri, il che li rende meno ideali in un contesto bayesiano puro. WAIC e LOOCV, al contrario, sono espressamente concepiti per stimare la performance predittiva su dati nuovi.\n\nQuando si riporta un confronto tra modelli, è buona norma includere non solo il modello \"vincente\", ma anche la differenza di ELPD con il suo errore standard, le diagnostiche sui parametri di Pareto-k, una stima della complessità effettiva e un commento sostantivo che spieghi il motivo della preferenza, che potrebbe risiedere nella parsimonia, nell'interpretabilità dei parametri o nella robustezza.\n\n#### In sintesi: il workflow essenziale\n\nUn mini-workflow consigliato per un approccio bayesiano prevede di: adattare i modelli; calcolare il LOO per ciascuno di essi e controllare i parametri di Pareto-k; se si riscontrano valori di k elevati, considerare una convalida incrociata K-fold o una LOO per cluster; confrontare i modelli con appositi strumenti e riportare le differenze di ELPD; opzionalmente, calcolare il WAIC come controllo incrociato; argomentare infine la scelta finale anche in base a parsimonia e interpretabilità.\n\nLa selezione del modello, in definitiva, ruota attorno a una domanda essenziale: quanto bene il modello predice dati che non ha mai visto? Il riferimento teorico è l’Expected Log Predictive Density (ELPD), che misura quanto la distribuzione predittiva del modello si avvicina alla vera distribuzione dei dati. Poiché quest'ultima è sconosciuta, l’ELPD va stimato con strumenti come LOO-CV e WAIC, che oggi rappresentano gli standard più affidabili per guidare una scelta consapevole, equilibrata e focalizzata sulla capacità di generalizzazione.\n\n\n## Riflessioni conclusive {.unnumbered .unlisted}\n\nIl principio fondamentale della modellazione bayesiana risiede nella valutazione della qualità di un modello attraverso la sua capacità di produrre previsioni probabilistiche robuste, rappresentate dalla distribuzione predittiva a posteriori $p(\\tilde{y} \\mid y)$.\n\nLa misura che guida questa valutazione è l'*Expected Log Predictive Density* (ELPD), che quantifica la capacità predittiva del modello su dati non osservati. A differenza delle metriche in-sample, soggette a sovradattamento, l'ELPD fornisce una stima imparziale della capacità di generalizzazione. Teoricamente, massimizzare l'ELPD equivale a minimizzare la divergenza di Kullback-Leibler rispetto alla vera distribuzione generatrice dei dati.\n\nOperativamente, l'ELPD viene stimato mediante PSIS-LOO, integrato con i diagnostici Pareto-k. Il WAIC costituisce un'alternativa bayesiana solida, spesso coerente con LOO. Al contrario, criteri come AIC e BIC, sebbene computazionalmente efficienti, si basano su stime puntuali e approssimazioni asintotiche, risultando meno affidabili in contesti di campioni piccoli o modelli gerarchici.\n\nNel confronto tra modelli, è essenziale riportare non solo l'ELPD-LOO, ma anche le differenze ΔELPD e i relativi errori standard. Tuttavia, la selezione del modello non dovrebbe ridursi a un esercizio meccanico: differenze trascurabili nell'ELPD, specialmente se associate ad alta incertezza, possono essere irrilevanti sul piano sostanziale. Modelli meno performanti ma più parsimoniosi o teoricamente fondati possono rappresentare scelte migliori.\n\nL'obiettivo finale è bilanciare capacità predittiva e coerenza teorica, ricordando che lo scopo della modellazione non è solo prevedere, ma comprendere. La valutazione deve quindi integrare strumenti come il PSIS-LOO con considerazioni sull'incertezza statistica, la struttura dei dati e il contesto teorico di riferimento.\n\n\n::: {.callout-note collapse=true title=\"Informazioni sull'ambiente di sviluppo\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsessionInfo()\n#> R version 4.5.1 (2025-06-13)\n#> Platform: aarch64-apple-darwin20\n#> Running under: macOS Sequoia 15.6.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRblas.0.dylib \n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.1\n#> \n#> locale:\n#> [1] C/UTF-8/C/C/C/C\n#> \n#> time zone: Europe/Rome\n#> tzcode source: internal\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> other attached packages:\n#>  [1] gt_1.0.0              pillar_1.11.0         tinytable_0.13.0     \n#>  [4] patchwork_1.3.2       ggdist_3.3.3          tidybayes_3.0.7      \n#>  [7] bayesplot_1.14.0      ggplot2_3.5.2         reliabilitydiag_0.2.1\n#> [10] priorsense_1.1.1      posterior_1.6.1       loo_2.8.0            \n#> [13] rstan_2.32.7          StanHeaders_2.32.10   brms_2.22.0          \n#> [16] Rcpp_1.1.0            sessioninfo_1.2.3     conflicted_1.2.0     \n#> [19] janitor_2.2.1         matrixStats_1.5.0     modelr_0.1.11        \n#> [22] tibble_3.3.0          dplyr_1.1.4           tidyr_1.3.1          \n#> [25] rio_1.2.3             here_1.0.1           \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] svUnit_1.0.8          tidyselect_1.2.1      farver_2.1.2         \n#>  [4] fastmap_1.2.0         TH.data_1.1-4         tensorA_0.36.2.1     \n#>  [7] digest_0.6.37         timechange_0.3.0      estimability_1.5.1   \n#> [10] lifecycle_1.0.4       survival_3.8-3        magrittr_2.0.3       \n#> [13] compiler_4.5.1        rlang_1.1.6           tools_4.5.1          \n#> [16] knitr_1.50            labeling_0.4.3        bridgesampling_1.1-2 \n#> [19] htmlwidgets_1.6.4     curl_7.0.0            pkgbuild_1.4.8       \n#> [22] xml2_1.4.0            RColorBrewer_1.1-3    abind_1.4-8          \n#> [25] multcomp_1.4-28       withr_3.0.2           purrr_1.1.0          \n#> [28] grid_4.5.1            stats4_4.5.1          colorspace_2.1-1     \n#> [31] xtable_1.8-4          inline_0.3.21         emmeans_1.11.2-8     \n#> [34] scales_1.4.0          MASS_7.3-65           cli_3.6.5            \n#> [37] mvtnorm_1.3-3         rmarkdown_2.29        ragg_1.5.0           \n#> [40] generics_0.1.4        RcppParallel_5.1.11-1 cachem_1.1.0         \n#> [43] stringr_1.5.1         splines_4.5.1         parallel_4.5.1       \n#> [46] vctrs_0.6.5           V8_7.0.0              Matrix_1.7-4         \n#> [49] sandwich_3.1-1        jsonlite_2.0.0        arrayhelpers_1.1-0   \n#> [52] systemfonts_1.2.3     glue_1.8.0            codetools_0.2-20     \n#> [55] distributional_0.5.0  lubridate_1.9.4       stringi_1.8.7        \n#> [58] gtable_0.3.6          QuickJSR_1.8.0        htmltools_0.5.8.1    \n#> [61] Brobdingnag_1.2-9     R6_2.6.1              textshaping_1.0.3    \n#> [64] rprojroot_2.1.1       evaluate_1.0.5        lattice_0.22-7       \n#> [67] backports_1.5.0       memoise_2.0.1         broom_1.0.9          \n#> [70] snakecase_0.11.1      rstantools_2.5.0      coda_0.19-4.1        \n#> [73] gridExtra_2.3         nlme_3.1-168          checkmate_2.3.3      \n#> [76] xfun_0.53             zoo_1.8-14            pkgconfig_2.0.3\n```\n:::\n\n:::\n\n## Bibliografia {.unnumbered .unlisted}\n\n",
    "supporting": [
      "03_model_comparison_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}