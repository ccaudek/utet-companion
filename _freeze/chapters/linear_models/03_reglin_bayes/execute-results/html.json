{
  "hash": "52d509bb6cea476e94ece9722d86b2d4",
  "result": {
    "engine": "knitr",
    "markdown": "# Modello bayesiano di regressione lineare bivariata {#sec-linmod-bayesian-reg}\n\n## Introduzione {.unnumbered .unlisted}\n\nNei capitoli precedenti abbiamo visto come la regressione lineare bivariata, nell’ottica frequentista, consenta di stimare la relazione tra due variabili attraverso il metodo dei minimi quadrati. Questo approccio, pur efficace, presenta limiti evidenti: si fonda su test d’ipotesi e p-value, non permette di integrare conoscenza pregressa e offre solo una descrizione indiretta dell’incertezza sui parametri.\n\nL’approccio *bayesiano* alla regressione propone una prospettiva diversa. L’idea centrale è la stessa che abbiamo incontrato in tutti i modelli precedenti: combiniamo un’informazione *a priori* con i dati osservati per ottenere una distribuzione *a posteriori*. In questo caso, i parametri della retta di regressione (intercetta, pendenza, varianza residua) non sono visti come valori fissi ma come quantità aleatorie, descritte da una distribuzione di probabilità.\n\nQuesta impostazione ci permette di:\n\n* esprimere in modo esplicito le nostre convinzioni iniziali sui parametri;\n* aggiornare tali convinzioni alla luce dei dati;\n* quantificare l’incertezza residua attraverso distribuzioni a posteriori, anziché affidarsi a intervalli di confidenza o a test dicotomici.\n\nIn questo capitolo vedremo come specificare e stimare un modello bayesiano di regressione lineare bivariata, partendo da ipotesi semplici e confrontando i risultati con quelli ottenuti nell’approccio frequentista. Sarà l’occasione per evidenziare i punti di forza del quadro bayesiano e comprendere meglio come interpretare i coefficienti di regressione in termini probabilistici.\n\n### Panoramica del capitolo {.unnumbered .unlisted}\n\n- Comprendere il modello di regressione bayesiano e come si differenzia dall'approccio frequentista.\n- Interpretare i parametri stimati in un contesto bayesiano e confrontarli con quelli frequentisti.\n- Familiarizzare con l'uso di *brms* nella regressione.\n- Interpretare le previsioni del modello bayesiano e le verifiche predittive a posteriori.\n\n::: {.callout-tip collapse=true}\n## Prerequisiti\n\n- Leggere l'@sec-apx-install-cmdstan.\n- Leggere il capitolo *Simple Normal Regression* di @Johnson2022bayesrules.\n- Consultare *Regression and Other Stories* [@gelman2021regression].\n  - Il pdf del libro è consultabile gratuitamente su questo [sito](https://avehtari.github.io/ROS-Examples/#Contents).\n  - Prestare particolare attenzione ai capitoli 1 \"Overeview, 6, \"Background on Regression Modeling,\" 7, \"Linear Regression with a Single Predictor\" e 8, \"Fitting regression models\", che offrono una guida dettagliata al modello di regressione bivariato da una prospettiva bayesiana.\n- Per utilizzare il pacchetto R *brms*, è necessario installare preliminarmente *Stan* o *CmdStan* sul proprio computer. Si consiglia di optare per *CmdStan*. Il metodo più semplice per installare *CmdStan* consiste nell'installare il pacchetto R *cmdstanr* e seguire le istruzioni fornite nella documentazione.\n:::\n\n::: {.callout-caution collapse=true title=\"Preparazione del Notebook\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhere::here(\"code\", \"_common.R\") |> \n  source()\n\n# Load packages\nif (!requireNamespace(\"pacman\")) install.packages(\"pacman\")\npacman::p_load(cmdstanr, posterior, see, brms)\n```\n:::\n\n:::\n\n## L’approccio bayesiano\n\nNella statistica frequentista, i parametri di un modello – come l'intercetta, la pendenza o la deviazione standard degli errori – vengono trattati come quantità fisse sebbene sconosciute. L'incertezza associata alle loro stime viene espressa indirettamente attraverso concetti quali intervalli di confidenza o valori-$p$ nei test di ipotesi.\n\nL'approccio bayesiano propone una prospettiva radicalmente diversa: i parametri sono considerati variabili aleatorie, ciascuna descritta da una propria distribuzione di probabilità. Questo framework consente di rappresentare l'incertezza in modo esplicito e diretto. Il processo inferenziale bayesiano si articola fondamentalmente in tre fasi.\n\nLa prima fase riguarda la scelta delle distribuzioni a priori. Prima di osservare i dati, viene assegnata a ciascun parametro una distribuzione di probabilità iniziale, detta prior, che incorpora ogni conoscenza preesistente o ipotesi plausibili sul fenomeno in studio. Ad esempio, se la letteratura scientifica suggerisce consistentemente che l'ansia riduca la performance, è possibile specificare un prior informativo per il coefficiente di regressione corrispondente, come una distribuzione normale centrata su un valore negativo con deviazione standard moderata, formalmente indicata come $b \\sim \\mathcal{N}(-0.7, 0.3)$. Al contrario, in assenza di informazioni preliminari solide, si può ricorrere a un prior debole o vago, che esprima una grande incertezza iniziale. Un prior di questo tipo, ad esempio $b \\sim \\mathcal{N}(0, 100)$, assegna probabilità pressoché uniformi a un ampio spettro di valori, permettendo ai dati osservati di dominare completamente la stima finale, che risulterà quindi molto vicina a quella ottenuta con metodi frequentisti.\n\nLa seconda fase consiste nell'aggiornamento delle credenze attraverso i dati osservati. Applicando il teorema di Bayes, le distribuzioni a priori vengono combinate con la verosimiglianza dei dati, dando origine alla distribuzione a posteriori dei parametri. Formalmente, questo si esprime attraverso la proporzionalità:\n\n$$\nP(a, b, \\sigma \\mid \\text{dati}) \\propto P(\\text{dati} \\mid a, b, \\sigma) \\cdot P(a, b, \\sigma).\n$$\n\nIl risultato di questo aggiornamento bayesiano è una distribuzione di probabilità congiunta per i parametri, che quantifica in modo probabilistico la plausibilità dei loro diversi valori, alla luce sia dell'evidenza empirica sia delle assunzioni iniziali.\n\nLa terza fase è dedicata all'interpretazione della distribuzione a posteriori. In questo approccio, non si ottiene un'unica stima puntuale per la retta di regressione, bensì un'intera famiglia di rette plausibili, ciascuna associata a un differente grado di credibilità probabilistica. L'incertezza viene sintetizzata e comunicata attraverso intervalli di credibilità. A differenza degli intervalli di confidenza di impostazione frequentista, un intervallo di credibilità bayesiano del 95% ammette un'interpretazione probabilistica diretta: esiste una probabilità del 95% che il vero valore del parametro sia contenuto al suo interno, dato il modello, i prior specificati e i dati osservati.\n\nL'approccio bayesiano offre diversi vantaggi, sia di natura pratica che teorica. Permette l'integrazione formale di conoscenze pregresse, facilitando la cumulatività della ricerca, ad esempio attraverso l'incorporazione di risultati di meta-analisi in nuovi studi. Mostra una notevole robustezza in presenza di campioni di piccole dimensioni, poiché i prior svolgono una funzione di regolarizzazione che stabilizza le stime, mitigando il rischio di overfitting. Fornisce, infine, interpretazioni intuitive dell'incertezza, allineate al ragionamento probabilistico naturale. Per queste ragioni, la statistica bayesiana risulta particolarmente adatta alla ricerca psicologica, un campo che spesso deve operare con campioni limitati e nel quale i nuovi risultati devono essere costantemente integrati in un corpus di conoscenze in evoluzione.\n\n## Il modello di regressione lineare semplice\n\nPer illustrare concretamente il modello di regressione lineare semplice, consideriamo un esempio di comune interesse in psicologia: prevedere il livello di ansia di un individuo (indicato con $y$) in base al numero di ore di sonno (indicato con $x$) da egli riportate. La relazione lineare tra queste due variabili viene formalizzata attraverso il modello:\n\n$$\ny_i = \\beta_0 + \\beta_1 x_i + \\varepsilon_i,\n$$\ndove $\\beta_0$ rappresenta l'intercetta, ovvero il valore atteso della variabile ansia quando il numero di ore di sonno è pari a zero. Il parametro $\\beta_1$ è il coefficiente di regressione, che quantifica la variazione attesa nel livello di ansia per ogni ora aggiuntiva di sonno. Il termine $\\varepsilon_i$ costituisce l'errore casuale, capace di catturare la deviazione del punteggio osservato di ansia del singolo individuo rispetto al valore predetto dalla retta di regressione.\n\nUn'assunzione fondamentale del modello riguarda proprio il termine di errore. Si assume che gli errori $\\varepsilon_i$ siano tra loro indipendenti e seguano una distribuzione normale con media zero e varianza costante $\\sigma^2$. Questa assunzione implica a sua volta che, per un dato valore di $x$, i valori osservati della variabile $y$ siano distribuiti normalmente attorno alla media condizionata $\\mu_i$. Formalmente:\n\n$$\ny_i \\mid x_i \\sim \\mathcal{N}(\\mu_i, \\sigma^2), \\quad \\text{dove} \\quad \\mu_i = \\beta_0 + \\beta_1 x_i.\n$$\n\nIn termini sostanziali, il modello non presuppone che tutti gli individui con lo stesso numero di ore di sonno presentino un identico livello di ansia. Piuttosto, esso descrive come i loro punteggi si distribuiscano in modo aleatorio attorno a un valore medio, il quale è deterministicamente determinato dalla relazione lineare con la variabile esplicativa. La retta di regressione rappresenta dunque la tendenza centrale di questa relazione, mentre la variabilità residua attorno alla retta è attribuita a fattori non misurati o al caso.\n\n### Cos’è la verosimiglianza?\n\nIl concetto di verosimiglianza rappresenta una misura fondamentale dell'adeguatezza di un insieme di parametri nel descrivere i dati osservati. Nel contesto della regressione lineare, la verosimiglianza dipende specificamente dai parametri β₀, β₁ e σ. \n\nPer ciascuna osservazione yᵢ, la probabilità di osservare quel particolare dato è espressa dalla funzione di densità di una distribuzione normale. Supponendo l'indipendenza delle osservazioni, la verosimiglianza congiunta per l'intero campione si ottiene attraverso il prodotto delle densità individuali:\n\n$$\n\\mathcal{L}(\\beta_0, \\beta_1, \\sigma \\mid \\mathbf{y}, \\mathbf{x}) = \\prod_{i=1}^n \\frac{1}{\\sqrt{2\\pi \\sigma^2}} \\exp\\!\\left(-\\frac{(y_i - \\beta_0 - \\beta_1 x_i)^2}{2\\sigma^2}\\right).\n$$\n\nData la complessità computazionale che deriva dal lavorare con prodotti di molteplici termini, nella pratica statistica si ricorre frequentemente alla log-verosimiglianza. Questa trasformazione, mantenendo le proprietà di ottimizzazione della funzione originale, converte il prodotto in una somma, semplificando notevolmente i calcoli:\n\n$$\n\\log \\mathcal{L}(\\beta_0, \\beta_1, \\sigma \\mid \\mathbf{y}, \\mathbf{x}) = -\\frac{n}{2}\\log(2\\pi) - n\\log\\sigma - \\frac{1}{2\\sigma^2}\\sum_{i=1}^n (y_i - \\beta_0 - \\beta_1 x_i)^2.\n$$\n\n#### Verosimiglianza: confronto tra approccio frequentista e bayesiano\n\nIl ruolo della verosimiglianza assume significati differenti nei due paradigmi statistici principali. Nell'approccio frequentista, la procedura di stima si basa sull'identificazione dei valori parametrici che massimizzano la funzione di verosimiglianza, dando origine al metodo della massima verosimiglianza. Questi valori costituiscono le stime puntuali considerate ottimali per i parametri del modello.\n\nNell'approccio bayesiano, la verosimiglianza rappresenta soltanto uno dei componenti del processo inferenziale. Essa viene integrata con le distribuzioni a priori assegnate ai parametri, attraverso l'applicazione del teorema di Bayes. Questa combinazione produce la distribuzione a posteriori, che costituisce la base per tutte le inferenze successive, fornendo una rappresentazione completa dell'incertezza associata ai parametri del modello.\n\n### Le distribuzioni a priori\n\nUn elemento caratterizzante dell'approccio bayesiano risiede nella specificazione delle distribuzioni a priori. Queste distribuzioni formalizzano matematicamente le credenze iniziali riguardo ai parametri del modello, prima di prendere in considerazione i dati osservati. È possibile identificare tre categorie principali di distribuzioni a priori.\n\nLe distribuzioni non informative intendono rappresentare una situazione di massima ignoranza o neutralità iniziale. Il loro obiettivo è permettere ai dati osservati di determinare completamente le stime finali, senza esercitare alcuna influenza sostanziale. Un esempio tipico è una distribuzione normale con media zero e varianza molto ampia, come $\\mathcal{N}(0, 1000)$.\n\nLe distribuzioni debolmente informative forniscono una regolarizzazione moderata, imponendo dei vincoli molto larghi ma in grado di evitare stime parametriche in regioni chiaramente implausibili o numericamente instabili. Questo tipo di prior può migliorare la stabilità delle stime, specialmente con campioni di piccole dimensioni, senza introdurre forti assunzioni sostanziali. Un esempio comune per un coefficiente di regressione potrebbe essere $\\mathcal{N}(0, 2.5)$.\n\nLe distribuzioni informative incorporano in modo esplicito conoscenze provenienti da letteratura preesistente, teorie consolidate o esperienza empirica. Sono caratterizzate da una varianza ridotta, che riflette un grado di certezza iniziale più elevato. Il loro utilizzo può aumentare notevolmente l'efficienza dell'inferenza ma richiede una solida giustificazione teorica o empirica per la scelta dei loro iperparametri.\n\n### Le distribuzioni a posteriori\n\nLa distribuzione a posteriori rappresenta il risultato fondamentale dell'inferenza bayesiana. Essa sorge dalla combinazione di due componenti: la verosimiglianza, che quantifica l'informazione contenuta nei dati osservati in relazione ai parametri, e le distribuzioni a priori, che esprimono le credenze iniziali.\n\nQuesta distribuzione congiunta a posteriori costituisce una rappresentazione probabilistica completa e aggiornata della nostra conoscenza riguardo ai parametri, condizionata all'evidenza empirica. A differenza delle tradizionali stime puntuali dell'approccio frequentista, il risultato bayesiano fornisce un'intera distribuzione di probabilità per ogni parametro. Questa ricchezza di informazione permette di quantificare l'incertezza in modo diretto e intuitivo, facilitando la costruzione di intervalli di credibilità e supportando un processo decisionale che integra coerentemente tutte le fonti di informazione disponibili.\n\n## Implementazione con `brms`\n\nNel pacchetto `brms` (che usa `Stan` come motore di calcolo), non è necessario scrivere la funzione di verosimiglianza a mano. Basta specificare il modello nella classica *forma di Wilkinson*:\n\n```r\nbrm(y ~ x, data = dati)\n```\n\nQuesta notazione compatta definisce il modello di regressione, la verosimiglianza implicita e consente a `brms` di costruire automaticamente il modello bayesiano. Se non si specificano i *prior*, `brms` utilizza prior debolmente informativi di default.\n\n\n### Come vengono stimate le distribuzioni a posteriori?\n\nPoiché la distribuzione a posteriori è spesso *troppo complessa per essere calcolata esattamente*, `brms` utilizza tecniche di *campionamento numerico* *MCMC* (Markov Chain Monte Carlo). In particolare, utilizza l’algoritmo *NUTS* (*No-U-Turn Sampler*), una variante evoluta dell’algoritmo di Metropolis-Hastings, che esplora lo spazio dei parametri in modo efficiente e adattivo. Grazie a questo, otteniamo *campioni dalla distribuzione a posteriori*, dai quali è possibile calcolare medie, intervalli di credibilità e fare previsioni.\n\nIn sintesi, il modello di regressione bayesiano consente di incorporare in modo trasparente incertezze, conoscenze pregresse e informazioni contenute nei dati. Rispetto all’approccio classico, non restituisce una singola stima puntuale ma un’intera distribuzione per ogni parametro. Questo permette inferenze più flessibili e più ricche di informazioni, particolarmente utili nelle scienze psicologiche, dove l’incertezza è la regola più che l’eccezione.\n\n\n### Un esempio concreto\n\nDefiniamo i parametri e simuliamo i dati.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(123)\n\n# Definizione delle variabili\nx <- 1:100\nn <- length(x)\na <- 1.5\nb <- 0.5\nsigma <- 10\n\n# Generazione di y\ny <- a + b * x + rnorm(n, 0, sigma)\n\n# Creazione del dataframe\nfake <- tibble(x = x, y = y)\nhead(fake)\n#> # A tibble: 6 × 2\n#>       x      y\n#>   <int>  <dbl>\n#> 1     1 -3.60 \n#> 2     2  0.198\n#> 3     3 18.6  \n#> 4     4  4.21 \n#> 5     5  5.29 \n#> 6     6 21.7\n```\n:::\n\n\nIniziamo adattando ai dati un modello frequentista:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfm1 <- lm(y ~ x, data = fake)\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsummary(fm1)\n#> \n#> Call:\n#> lm(formula = y ~ x, data = fake)\n#> \n#> Residuals:\n#>     Min      1Q  Median      3Q     Max \n#> -24.536  -5.524  -0.346   6.485  20.949 \n#> \n#> Coefficients:\n#>             Estimate Std. Error t value Pr(>|t|)\n#> (Intercept)   1.1360     1.8429    0.62     0.54\n#> x             0.5251     0.0317   16.57   <2e-16\n#> \n#> Residual standard error: 9.15 on 98 degrees of freedom\n#> Multiple R-squared:  0.737,\tAdjusted R-squared:  0.734 \n#> F-statistic:  275 on 1 and 98 DF,  p-value: <2e-16\n```\n:::\n\n\nPer ottenere l’intervallo di confidenza (nel senso frequentista) della stima dei parametri usiamo:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nconfint(fm1, level = 0.95)\n#>              2.5 % 97.5 %\n#> (Intercept) -2.521  4.793\n#> x            0.462  0.588\n```\n:::\n\n\nAdattiamo ora ai dati un modello di regressione bayesiano utilizzando *brms*. Si noti che, anche in questo caso, usiamo la sintassi di Wilkinson `y ~ x`, come per *lm()*.  Eseguiamo il campionamento:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfm2 <- brm(\n  y ~ x, \n  data = fake,\n  backend = \"cmdstanr\"\n)\n```\n:::\n\n\nCome discusso nell'analisi dell'algoritmo di Metropolis, il primo passo è esaminare le tracce dei parametri per verificare la convergenza dell'algoritmo. La convergenza può essere considerata raggiunta se le catene (nel caso di `brm`, sono 4 per impostazione predefinita) risultano ben mescolate. Questo si manifesta in un *trace plot* che mostra una distribuzione uniforme e casuale dei campioni attorno a un valore centrale, senza pattern evidenti o tendenze sistematiche.\n\nLe tracce dei parametri si ottengono nel modo seguente:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmcmc_trace(\n  fm2, \n  pars = c(\"b_Intercept\", \"b_x\", \"sigma\"),\n  facet_args = list(nrow = 3)\n)\n```\n\n::: {.cell-output-display}\n![](03_reglin_bayes_files/figure-html/unnamed-chunk-7-1.png){fig-align='center' width=85%}\n:::\n:::\n\n\nGli istogrammi delle distribuzioni a posteriori dei parametri si generano nel modo seguente:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmcmc_hist(\n  fm2, \n  pars =c(\"b_Intercept\", \"b_x\", \"sigma\"),\n  facet_args = list(nrow = 3)\n)\n```\n\n::: {.cell-output-display}\n![](03_reglin_bayes_files/figure-html/unnamed-chunk-8-1.png){fig-align='center' width=85%}\n:::\n:::\n\n\nPer valutare l'autocorrelazione tra i campioni a posteriori del parametro `beta`, possiamo utilizzare il seguente comando:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmcmc_acf(fm2, \"b_x\")\n```\n\n::: {.cell-output-display}\n![](03_reglin_bayes_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=85%}\n:::\n:::\n\n\nL'autocorrelazione fornisce informazioni sulla dipendenza tra campioni successivi nella catena di Markov. È normale che i campioni successivi non siano completamente indipendenti, poiché le catene di Markov generano campioni correlati per costruzione. Tuttavia, se l'algoritmo ha raggiunto la convergenza, l'autocorrelazione dovrebbe diminuire rapidamente e diventare trascurabile dopo un numero relativamente piccolo di lag. Questo significa che, dopo un certo numero di passi, i campioni diventano progressivamente meno correlati tra loro, comportandosi in modo simile a campioni indipendenti estratti dalla distribuzione target.\n\nUn'elevata autocorrelazione su lag più lunghi potrebbe invece indicare problemi di mescolamento delle catene o una mancata convergenza, richiedendo ulteriori verifiche o aggiustamenti, come l'aumento del numero di iterazioni o una diversa parametrizzazione del modello.\n\nNel caso presente, notiamo una rapida diminuzione dell'autocorrelazione in funzione del numero di passi. Ciò è indicativo del fatto che la convergenza è stata raggiunta.\n\nUna sintesi numerica dei risultati si trova nel modo seguente:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsummary(fm2)\n#>  Family: gaussian \n#>   Links: mu = identity; sigma = identity \n#> Formula: y ~ x \n#>    Data: fake (Number of observations: 100) \n#>   Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n#>          total post-warmup draws = 4000\n#> \n#> Regression Coefficients:\n#>           Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\n#> Intercept     1.17      1.79    -2.34     4.64 1.00     3981     2679\n#> x             0.52      0.03     0.46     0.59 1.00     4004     2919\n#> \n#> Further Distributional Parameters:\n#>       Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\n#> sigma     9.24      0.68     8.02    10.71 1.00     3848     2991\n#> \n#> Draws were sampled using sample(hmc). For each parameter, Bulk_ESS\n#> and Tail_ESS are effective sample size measures, and Rhat is the potential\n#> scale reduction factor on split chains (at convergence, Rhat = 1).\n```\n:::\n\n\nConfrontiamo le stime ottenute con i valori reali dei parametri simulati. L'intercetta è stata stimata attorno a 1.14, con un'incertezza al 95% che varia tra -2.4 e 4.8. Questo risultato rientra negli intervalli di credibilità previsti, confermando l'accuratezza del modello. Analogamente, per la pendenza $b$, l'intervallo di credibilità al 95% include il valore reale simulato, dimostrando come le stime bayesiane riflettano accuratamente l'incertezza sui parametri.\n\nSe si utilizza la funzione `conditional_effects()` viene prodotto un grafico che rappresenta la relazione stimata tra il predittore $x$ e la variabile di risposta $y$.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nconditional_effects(fm2) |>\n  plot(points = TRUE)\n```\n\n::: {.cell-output-display}\n![](03_reglin_bayes_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=85%}\n:::\n:::\n\n\n1. *Linea stimata (effetto medio):*\n   - La linea centrale del grafico rappresenta il valore medio previsto di $y$ per ogni valore di $x$, dato dalla relazione $y = \\alpha + \\beta x$.\n   - Questa linea è calcolata usando i valori medi a posteriori stimati per $\\alpha$ e $\\beta$.\n\n2. *Bande di incertezza (intervalli di credibilità):*\n   - Le bande attorno alla linea rappresentano gli intervalli di credibilità (ad esempio, al 95%). Questi mostrano l'incertezza associata alle stime del modello per ogni valore di $x$.\n   - Più strette sono le bande, maggiore è la certezza del modello riguardo alla relazione stimata.\n\n3. *Dati osservati:*\n   - I punti rappresentano i valori effettivi di $y$ osservati nei dati. Questo consente di confrontare visivamente come i dati reali si allineano con le previsioni del modello.\n\nIl grafico consente \n\n- una verifica visiva della relazione stimata tra $y$ e $x$;\n- di identificazione di eventuali discrepanze tra i dati osservati e le previsioni del modello;\n- una rappresentazione dell'incertezza nelle stime.\n\nAd esempio, il grafico può mostrare se $x$ ha un effetto credibile su $y$ e con quale livello di incertezza. Se l'effetto di $x$ è debole o nullo, la linea stimata sarà piatta (vicina a zero) e le bande di incertezza saranno ampie.\n\n\n## Simulazione di livelli di copertura\n\nVerifichiamo la copertura degli intervalli di credibilità al 95% attraverso simulazioni ripetute.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(42)\n# Parametri veri\na_true <- 0.2\nb_true <- 0.3\nsigma_true <- 0.5\n# Numero di simulazioni\nnum_simulations <- 100\n# Conteggio delle coperture\ncoverage_a <- 0\ncoverage_b <- 0\nfor (i in 1:num_simulations) {\n  # Generazione dei dati\n  x <- 1:20\n  y <- a_true + b_true * x + sigma_true * rnorm(length(x))\n  # Adattamento del modello\n  fit <- lm(y ~ x)\n  ci <- confint(fit) # Intervalli di confidenza\n  # Verifica delle coperture\n  if (ci[1,1] <= a_true & ci[1, 2] >= a_true) {\n    coverage_a <- coverage_a + 1\n  }\n  if (ci[2,1] <= b_true & ci[2, 2] >= b_true) {\n    coverage_b <- coverage_b + 1\n  }\n}\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Risultati\ncat(\"Coverage for a:\", coverage_a / num_simulations, \"\\n\")\n#> Coverage for a: 0.93\ncat(\"Coverage for b:\", coverage_b / num_simulations, \"\\n\")\n#> Coverage for b: 0.96\n```\n:::\n\n\nI risultati indicano che i livelli di copertura empirici ottenuti con l'approccio frequentista corrispondono strettamente ai livelli teorici attesi.\n\nPer proseguire, ripeteremo la simulazione adottando un approccio bayesiano. Useremo la funzione `brm()` del pacchetto *brms* al posto di `lm()`. \n\n```r\n#| message: false\n#| warning: false\n#| output: false\n#| \nset.seed(23)\nn_fake   <- 100\ncover_68 <- logical(n_fake)\ncover_95 <- logical(n_fake)\n\n# Veri parametri\na     <- 0.2    # intercetta vera\nb     <- 0.3    # pendenza vera\nsigma <- 0.5    # deviazione standard vera\nx     <- 1:20\nn     <- length(x)\n\n# Priors con set_prior \npriors <- c(\n  set_prior(\"normal(0, 2.5)\", class = \"Intercept\"),\n  set_prior(\"normal(0, 2.5)\", class = \"b\", coef = \"x\"),\n  set_prior(\"cauchy(0, 2.5)\", class = \"sigma\")\n)\n\nset.seed(23)\nn_fake   <- 1000\ncover_68 <- logical(n_fake)\ncover_95 <- logical(n_fake)\n\na     <- 0.2\nb     <- 0.3\nsigma <- 0.5\nx     <- 1:20\nn     <- length(x)\n\nfor (s in seq_len(n_fake)) {\n  y    <- a + b * x + rnorm(n, 0, sigma)\n  fake <- data.frame(x = x, y = y)\n\n  fit <- brm(\n    y ~ 1 + x,\n    data    = fake,\n    family  = gaussian(),\n    prior   = priors,\n    iter    = 2000,\n    chains  = 2,\n    refresh = 0,\n    backend = \"cmdstanr\"\n  )\n\n  post <- summary(fit)$fixed\n  b_hat <- post[\"x\", \"Estimate\"]\n  b_se  <- post[\"x\", \"Est.Error\"]\n\n  cover_68[s] <- abs(b - b_hat) < b_se\n  cover_95[s] <- abs(b - b_hat) < 2 * b_se\n}\n\ncat(\"Coverage 68%:\", mean(cover_68), \"\\n\")\ncat(\"Coverage 95%:\", mean(cover_95), \"\\n\")\n```\n\nCon solo 100 iterazioni, i risultati sono i seguenti:\n\n```r\n> cat(\"Coverage 68%:\", mean(cover_68), \"\\n\")\nCoverage 68%: 0.73 \n> cat(\"Coverage 95%:\", mean(cover_95), \"\\n\")\nCoverage 95%: 0.953 \n```\n\nQuesta seconda simulazione evidenzia che anche i livelli di copertura empirici ottenuti con l'approccio bayesiano si avvicinano ai valori teorici previsti.\n\nI risultati ottenuti confermano l'efficacia degli intervalli di confidenza e di credibilità stimati attraverso i modelli frequentisti e bayesiani.\n\n## Confronti, non effetti\n\n@gelman2021regression mettono in guardia contro un'interpretazione eccessivamente causale dei coefficienti di regressione. Sebbene nella pratica statistica sia comune riferirsi a questi coefficienti come \"effetti\", tale terminologia può risultare fuorviante poiché suggerisce implicitamente l'esistenza di un nesso causale. In realtà, ciò che un modello di regressione stima rappresenta fondamentalmente un pattern osservazionale. Più precisamente, il coefficiente β₁ associato a una variabile esplicativa X cattura la differenza attesa nella media della variabile dipendente Y tra due sottopopolazioni che differiscono di un'unità nel valore di X.\n\nLa regressione lineare è essenzialmente uno strumento matematico progettato per analizzare associazioni e migliorare la capacità predittiva. I suoi coefficienti vanno interpretati primariamente come confronti medi tra gruppi definiti dai valori delle variabili esplicative. Un'interpretazione causale di questi coefficienti è legittima soltanto in contesti sperimentali specifici o quando il disegno di ricerca incorpora strategie identificative appropriate, come l'utilizzo di variabili strumentali, regression discontinuity design o altri metodi che mirano a controllare la confondazione. Tale interpretazione non può mai essere dedotta automaticamente dalla stima del modello statistico, ma deve essere giustificata da considerazioni metodologiche sostanziali relative al processo di generazione dei dati.\n\n## Riflessioni conclusive {.unnumbered .unlisted}\n\nIn questo capitolo abbiamo riformulato la regressione lineare bivariata in chiave bayesiana. Abbiamo visto come l’adozione di distribuzioni a priori per i parametri — intercetta, pendenza e varianza residua — permetta di combinare conoscenze pregresse con i dati osservati, producendo distribuzioni a posteriori che rappresentano in modo diretto l’incertezza sulle quantità di interesse.\n\nIl confronto con l’approccio frequentista mette in luce differenze sostanziali. Mentre il frequentismo si concentra su stime puntuali, intervalli di confidenza e test di ipotesi, il bayesianesimo restituisce l’intera distribuzione di probabilità dei parametri, consentendo affermazioni più trasparenti e interpretabili. In questo quadro, parlare della “plausibilità” di un coefficiente, o della probabilità che una pendenza sia positiva o negativa, non è più un abuso di linguaggio ma il cuore stesso dell’inferenza.\n\nNaturalmente, il prezzo da pagare è quello computazionale. Le soluzioni analitiche sono disponibili solo in casi semplici, come il modello qui discusso. Nei problemi reali, con più predittori o con strutture di dati complesse, dobbiamo ricorrere a metodi di approssimazione numerica. È qui che entrano in gioco i metodi di campionamento e gli strumenti software sviluppati negli ultimi decenni.\n\nNei prossimi capitoli introdurremo quindi *Stan*, un linguaggio di programmazione pensato per la stima di modelli bayesiani complessi, che automatizza i passaggi computazionali e rende accessibile l’inferenza anche in situazioni dove il calcolo diretto sarebbe impossibile. La regressione bivariata diventa così il banco di prova ideale per comprendere la logica bayesiana prima di affrontare modelli più ricchi e realistici.\n\n::: {.callout-important title=\"Problemi\" collapse=\"true\"}\n\n1. **Verosimiglianza**  \n   Definire la funzione di verosimiglianza per il modello bayesiano di regressione lineare bivariata, esplicitando i parametri e la loro interpretazione.\n\n2. **Scelta dei prior**  \n   Proporre un set di prior debolmente informativi differenti da quelli riportati, motivando la scelta delle distribuzioni.\n\n3. **Simulazione dati**  \n   Scrivere un blocco di codice in R/Quarto per simulare un dataset con $n=50$, parametri $lpha=2$, $eta=0.5$, $\\sigma=1$ e visualizzare un grafico dispersione con la retta di regressione vera.\n\n4. **Stima frequentista vs bayesiana**  \n   Utilizzando i dati simulati, adattare un modello con `lm()` e uno con `brm()` (specificando i prior). Confrontare i risultati prodotti dai due approcci, riportando i valori stimati e gli intervalli di confidenza/credibilità.\n\n5. **Diagnosi MCMC**  \n   Elencare e spiegare almeno tre controlli diagnostici da effettuare sulle catene MCMC per garantire la convergenza e un buon mescolamento.\n\n6. **Interpretazione dei coefficienti**  \n   In un contesto osservazionale, discutere perché non è appropriato interpretare i coefficienti della regressione come effetti causali. Fare riferimento ai concetti di confondimento e disegno sperimentale.\n\n:::\n\n::: {.callout-tip title=\"Soluzioni\" collapse=\"true\"}\n\n1. **Verosimiglianza**  \n\n   $$\n   \\mathcal{L}(\\alpha, \\beta, \\sigma \\mid y, x) = \\prod_{i=1}^n \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left(-\\frac{(y_i - (\\alpha + \\beta x_i))^2}{2\\sigma^2}\\right).\n   $$\n\n2. **Scelta dei prior**  \n\n   Ad esempio:  \n   \n   - $\\alpha \\sim \\mathcal{N}(0, 5)$: consente maggiore variabilità iniziale;  \n   - $\\beta \\sim \\text{Student-}t(3, 0, 2)$: robuste alle code pesanti;  \n   - $\\sigma \\sim \\text{Half-}Cauchy(0, 1)$: prior leggermente più stretto sulle deviazioni.\n\n3. **Simulazione dati**  \n\n   ```r\n   set.seed(42)\n   n <- 50\n   alpha <- 2\n   beta  <- 0.5\n   sigma <- 1\n   x <- rnorm(n, 0, 1)\n   y <- alpha + beta * x + rnorm(n, 0, sigma)\n   plot(x, y, main = \"Dati simulati\", xlab = \"x\", ylab = \"y\")\n   abline(a = alpha, b = beta, col = \"blue\", lwd = 2)\n   ```\n\n4. **Stima frequentista vs bayesiana**  \n\n   - Frequentista (`lm()`):  \n   \n     ```r\n     fm_f <- lm(y ~ x)\n     summary(fm_f)\n     confint(fm_f, level = 0.95)\n     ```  \n   - Bayesiano (`brm()`):  \n   \n     ```r\n     fm_b <- brm(y ~ x, data = data.frame(x, y),\n                 prior = c(set_prior(\"normal(0,5)\", class=\"Intercept\"),\n                           set_prior(\"normal(0,5)\", class=\"b\"),\n                           set_prior(\"cauchy(0,1)\", class=\"sigma\")),\n                 iter = 2000, chains = 2)\n     summary(fm_b)\n     \n     ```  \n   Confronto: i valori medi a posteriori e gli intervalli di credibilità dovrebbero includere quelli di confidenza di `lm()`.\n\n5. **Diagnosi MCMC**  \n\n   - *Trace plots*: verificare mescolamento e stazionarietà delle catene;  \n   - *R-hat*: valore vicino a 1 indica convergenza;  \n   - *Effective Sample Size (ESS)*: numero di campioni indipendenti effettivi.\n\n6. **Interpretazione dei coefficienti**  \n   La regressione osservazionale non controlla automaticamente i potenziali confondenti; senza randomizzazione o disegno sperimentale rigoroso, non si può inferire causalità. Bisogna considerare variabili confondenti e criteri di validità interna.\n\n:::\n\n\n::: {.callout-note collapse=true title=\"Informazioni sull'ambiente di sviluppo\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsessionInfo()\n#> R version 4.5.1 (2025-06-13)\n#> Platform: aarch64-apple-darwin20\n#> Running under: macOS Sequoia 15.6.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRblas.0.dylib \n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.1\n#> \n#> locale:\n#> [1] C/UTF-8/C/C/C/C\n#> \n#> time zone: Europe/Rome\n#> tzcode source: internal\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> other attached packages:\n#>  [1] see_0.11.0            cmdstanr_0.9.0        pillar_1.11.0        \n#>  [4] tinytable_0.13.0      patchwork_1.3.2       ggdist_3.3.3         \n#>  [7] tidybayes_3.0.7       bayesplot_1.14.0      ggplot2_3.5.2        \n#> [10] reliabilitydiag_0.2.1 priorsense_1.1.1      posterior_1.6.1      \n#> [13] loo_2.8.0             rstan_2.32.7          StanHeaders_2.32.10  \n#> [16] brms_2.22.0           Rcpp_1.1.0            sessioninfo_1.2.3    \n#> [19] conflicted_1.2.0      janitor_2.2.1         matrixStats_1.5.0    \n#> [22] modelr_0.1.11         tibble_3.3.0          dplyr_1.1.4          \n#> [25] tidyr_1.3.1           rio_1.2.3             here_1.0.1           \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] gridExtra_2.3         inline_0.3.21         sandwich_3.1-1       \n#>  [4] rlang_1.1.6           magrittr_2.0.3        multcomp_1.4-28      \n#>  [7] snakecase_0.11.1      compiler_4.5.1        reshape2_1.4.4       \n#> [10] systemfonts_1.2.3     vctrs_0.6.5           stringr_1.5.1        \n#> [13] pkgconfig_2.0.3       arrayhelpers_1.1-0    fastmap_1.2.0        \n#> [16] backports_1.5.0       labeling_0.4.3        rmarkdown_2.29       \n#> [19] ps_1.9.1              ragg_1.5.0            purrr_1.1.0          \n#> [22] xfun_0.53             cachem_1.1.0          jsonlite_2.0.0       \n#> [25] broom_1.0.9           parallel_4.5.1        R6_2.6.1             \n#> [28] stringi_1.8.7         RColorBrewer_1.1-3    lubridate_1.9.4      \n#> [31] estimability_1.5.1    knitr_1.50            zoo_1.8-14           \n#> [34] pacman_0.5.1          Matrix_1.7-4          splines_4.5.1        \n#> [37] timechange_0.3.0      tidyselect_1.2.1      abind_1.4-8          \n#> [40] yaml_2.3.10           codetools_0.2-20      curl_7.0.0           \n#> [43] processx_3.8.6        pkgbuild_1.4.8        plyr_1.8.9           \n#> [46] lattice_0.22-7        withr_3.0.2           bridgesampling_1.1-2 \n#> [49] coda_0.19-4.1         evaluate_1.0.5        survival_3.8-3       \n#> [52] RcppParallel_5.1.11-1 tensorA_0.36.2.1      checkmate_2.3.3      \n#> [55] stats4_4.5.1          distributional_0.5.0  generics_0.1.4       \n#> [58] rprojroot_2.1.1       rstantools_2.5.0      scales_1.4.0         \n#> [61] xtable_1.8-4          glue_1.8.0            emmeans_1.11.2-8     \n#> [64] tools_4.5.1           data.table_1.17.8     mvtnorm_1.3-3        \n#> [67] grid_4.5.1            QuickJSR_1.8.0        colorspace_2.1-1     \n#> [70] nlme_3.1-168          cli_3.6.5             textshaping_1.0.3    \n#> [73] svUnit_1.0.8          Brobdingnag_1.2-9     V8_7.0.0             \n#> [76] gtable_0.3.6          digest_0.6.37         TH.data_1.1-4        \n#> [79] htmlwidgets_1.6.4     farver_2.1.2          memoise_2.0.1        \n#> [82] htmltools_0.5.8.1     lifecycle_1.0.4       MASS_7.3-65\n```\n:::\n\n:::\n\n\n## Bibliografia {.unnumbered .unlisted}\n\n",
    "supporting": [
      "03_reglin_bayes_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}